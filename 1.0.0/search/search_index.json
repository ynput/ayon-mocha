{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Mocha Pro Addon","text":"<p>BorisFx Mocha Pro integration for AYON.</p> <p>The Mocha Pro Addon for AYON provide features to manage you Mocha Pro workfiles, load clips and publish tracking data and shape data.</p>"},{"location":"index.html#installation","title":"Installation","text":"<p>You can either use AYON's Addon Market or you can build and install the addon manually.</p> <p>To install this addon to your AYON instance, just run the following command:</p> <pre><code>python ./create_package.py\n</code></pre> <p>This will create a package file that you can upload to your AYON instance in Addon Bundle configuration page.</p>"},{"location":"index.html#dev-resources","title":"Dev resources","text":"<ul> <li>Python API: https://borisfx.com/documentation/mocha/python/</li> </ul>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_mocha<ul> <li>addon</li> <li>api<ul> <li>lib</li> <li>mocha_exporter_mappings</li> <li>pipeline</li> <li>plugin</li> <li>workio</li> </ul> </li> <li>plugins<ul> <li>create<ul> <li>create_shape_data</li> <li>create_tracking_points</li> <li>create_workfile</li> </ul> </li> <li>load<ul> <li>load_clip</li> <li>load_trackable_clip</li> </ul> </li> <li>publish<ul> <li>collect_instances</li> <li>collect_mocha_paths</li> <li>collect_mocha_project</li> <li>collect_shapes</li> <li>collect_trackpoints</li> <li>collect_workfile</li> <li>export_shapes</li> <li>export_tracking_points</li> <li>validate_layers_and_exporters</li> <li>validate_trackpoints_layers</li> </ul> </li> </ul> </li> <li>resources</li> <li>startup<ul> <li>init</li> </ul> </li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>settings<ul> <li>creator_plugins</li> <li>main</li> </ul> </li> </ul> </li> </ul>"},{"location":"autoapi/client/index.html","title":"client","text":""},{"location":"autoapi/client/ayon_mocha/index.html","title":"ayon_mocha","text":"<p>Mocha Addon for Ayon.</p>"},{"location":"autoapi/client/ayon_mocha/index.html#client.ayon_mocha.MochaAddon","title":"<code>MochaAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IHostAddon</code></p> <p>BorisFX Mocha Pro addon for AYON.</p> Source code in <code>client/ayon_mocha/addon.py</code> <pre><code>class MochaAddon(AYONAddon, IHostAddon):\n    \"\"\"BorisFX Mocha Pro addon for AYON.\"\"\"\n\n    name = \"mocha\"\n    host_name = \"mochapro\"\n    title = \"Mocha Pro\"\n    version = __version__\n\n    @staticmethod\n    def add_implementation_envs(env: dict[str, str], _app: Any) -&gt; None:  # noqa: ANN401\n        \"\"\"Add implementation environment variables.\"\"\"\n        startup_path = os.path.join(MOCHA_ADDON_ROOT, \"startup\")\n        env[\"MOCHA_INIT_SCRIPT\"] = startup_path\n\n    def get_workfile_extensions(self) -&gt; list[str]:  # noqa: PLR6301\n        \"\"\"Return supported workfile extensions.\"\"\"\n        return [\".mocha\"]\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/index.html#client.ayon_mocha.MochaAddon.add_implementation_envs","title":"<code>add_implementation_envs(env, _app)</code>  <code>staticmethod</code>","text":"<p>Add implementation environment variables.</p> Source code in <code>client/ayon_mocha/addon.py</code> <pre><code>@staticmethod\ndef add_implementation_envs(env: dict[str, str], _app: Any) -&gt; None:  # noqa: ANN401\n    \"\"\"Add implementation environment variables.\"\"\"\n    startup_path = os.path.join(MOCHA_ADDON_ROOT, \"startup\")\n    env[\"MOCHA_INIT_SCRIPT\"] = startup_path\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/index.html#client.ayon_mocha.MochaAddon.get_workfile_extensions","title":"<code>get_workfile_extensions()</code>","text":"<p>Return supported workfile extensions.</p> Source code in <code>client/ayon_mocha/addon.py</code> <pre><code>def get_workfile_extensions(self) -&gt; list[str]:  # noqa: PLR6301\n    \"\"\"Return supported workfile extensions.\"\"\"\n    return [\".mocha\"]\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/addon.html","title":"addon","text":"<p>BorisFX Mocha Pro addon for AYON.</p>"},{"location":"autoapi/client/ayon_mocha/addon.html#client.ayon_mocha.addon.MochaAddon","title":"<code>MochaAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IHostAddon</code></p> <p>BorisFX Mocha Pro addon for AYON.</p> Source code in <code>client/ayon_mocha/addon.py</code> <pre><code>class MochaAddon(AYONAddon, IHostAddon):\n    \"\"\"BorisFX Mocha Pro addon for AYON.\"\"\"\n\n    name = \"mocha\"\n    host_name = \"mochapro\"\n    title = \"Mocha Pro\"\n    version = __version__\n\n    @staticmethod\n    def add_implementation_envs(env: dict[str, str], _app: Any) -&gt; None:  # noqa: ANN401\n        \"\"\"Add implementation environment variables.\"\"\"\n        startup_path = os.path.join(MOCHA_ADDON_ROOT, \"startup\")\n        env[\"MOCHA_INIT_SCRIPT\"] = startup_path\n\n    def get_workfile_extensions(self) -&gt; list[str]:  # noqa: PLR6301\n        \"\"\"Return supported workfile extensions.\"\"\"\n        return [\".mocha\"]\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/addon.html#client.ayon_mocha.addon.MochaAddon.add_implementation_envs","title":"<code>add_implementation_envs(env, _app)</code>  <code>staticmethod</code>","text":"<p>Add implementation environment variables.</p> Source code in <code>client/ayon_mocha/addon.py</code> <pre><code>@staticmethod\ndef add_implementation_envs(env: dict[str, str], _app: Any) -&gt; None:  # noqa: ANN401\n    \"\"\"Add implementation environment variables.\"\"\"\n    startup_path = os.path.join(MOCHA_ADDON_ROOT, \"startup\")\n    env[\"MOCHA_INIT_SCRIPT\"] = startup_path\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/addon.html#client.ayon_mocha.addon.MochaAddon.get_workfile_extensions","title":"<code>get_workfile_extensions()</code>","text":"<p>Return supported workfile extensions.</p> Source code in <code>client/ayon_mocha/addon.py</code> <pre><code>def get_workfile_extensions(self) -&gt; list[str]:  # noqa: PLR6301\n    \"\"\"Return supported workfile extensions.\"\"\"\n    return [\".mocha\"]\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/version.html","title":"version","text":"<p>Package declaring AYON addon 'mocha' version.</p>"},{"location":"autoapi/client/ayon_mocha/api/index.html","title":"api","text":"<p>API for Mocha Pro AYON plugin.</p>"},{"location":"autoapi/client/ayon_mocha/api/index.html#client.ayon_mocha.api.MochaProHost","title":"<code>MochaProHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> <p>Mocha Pro host implementation.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>class MochaProHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n    \"\"\"Mocha Pro host implementation.\"\"\"\n\n    name = \"mochapro\"\n    _uninitialized_project_warning_shown = False\n\n    def install(self) -&gt; None:\n        \"\"\"Initialize the host.\"\"\"\n        pyblish.api.register_host(self.name)\n        pyblish.api.register_plugin_path(PUBLISH_PATH.as_posix())\n        register_loader_plugin_path(LOAD_PATH.as_posix())\n        register_creator_plugin_path(CREATE_PATH.as_posix())\n\n        # QtCore.QTimer.singleShot(0, self._install_menu)\n        self._install_menu()\n\n    def _install_menu(self) -&gt; None:\n        \"\"\"Install the menu.\"\"\"\n        main_window = get_main_window()\n\n        menu_label = os.getenv(\"AYON_MENU_LABEL\", \"AYON\")\n        menu = main_window.menuBar().addMenu(menu_label)\n\n        action = menu.addAction(\"Current Context\")\n\n        def _on_menu_about_to_show(menu_action: QtWidgets.QAction) -&gt; None:\n            \"\"\"Update the menu.\"\"\"\n            context = self.get_current_context()\n            menu_action.setText(\n                f\"{context['folder_path']}, {context['task_name']}\")\n\n        action.setEnabled(False)\n        menu.aboutToShow.connect(partial(_on_menu_about_to_show, action))\n        menu.addSeparator()\n\n        action = menu.addAction(\"Create...\")\n        action.triggered.connect(\n            lambda: host_tools.show_publisher(\n                parent=main_window, tab=\"create\"))\n\n        action = menu.addAction(\"Load...\")\n        action.triggered.connect(\n            lambda: host_tools.show_loader(\n                parent=main_window, use_context=True))\n\n        action = menu.addAction(\"Publish...\")\n        action.triggered.connect(\n            lambda: host_tools.show_publisher(\n                parent=main_window, tab=\"publish\"))\n\n        action = menu.addAction(\"Manage...\")\n        action.triggered.connect(\n            lambda: host_tools.show_scene_inventory(parent=main_window))\n\n        action = menu.addAction(\"Library...\")\n        action.triggered.connect(\n            lambda: host_tools.show_library_loader(parent=main_window))\n\n        menu.addSeparator()\n\n        action = menu.addAction(\"Work Files...\")\n        action.triggered.connect(\n            lambda: host_tools.show_workfiles(parent=main_window))\n\n        menu.addSeparator()\n\n        action = menu.addAction(\"Reset Frame Range and FPS\")\n        action.triggered.connect(\n            lambda: reset_frame_range(self.get_current_project()))\n\n        menu.addSeparator()\n\n        action = menu.addAction(\"Experimental Tools...\")\n        action.triggered.connect(\n            lambda: host_tools.show_experimental_tools_dialog(\n                parent=main_window))\n\n    def get_workfile_extensions(self) -&gt; list[str]:  # noqa: PLR6301\n        \"\"\"Get the workfile extensions.\n\n        Returns:\n            list[str]: Workfile extensions.\n\n        \"\"\"\n        return file_extensions()\n\n    def save_workfile(self, dst_path: Optional[str] = None) -&gt; None:  # noqa: PLR6301\n        \"\"\"Save the workfile.\n\n        Args:\n            dst_path (str, optional): The destination path to save the file to.\n                Defaults to None.\n\n        Todo (antirotor): This needs to display error if the project\n            isn't initialized yet.\n            https://github.com/ynput/ayon-core/issues/1075\n\n        \"\"\"\n        if dst_path:\n            save_file(Path(dst_path))\n        else:\n            save_file(filepath=None)\n        if not _get_current_project():\n            reset_frame_range(_get_current_project())\n\n    def open_workfile(self, filepath: str) -&gt; None:  # noqa: PLR6301\n        \"\"\"Open the workfile.\"\"\"\n        open_file(Path(filepath))\n\n    def get_current_workfile(self) -&gt; Optional[str]:  # noqa: PLR6301\n        \"\"\"Get the current workfile.\n\n        Returns:\n            Optional[str]: The current workfile.\n\n        \"\"\"\n        file_path = current_file()\n        return file_path.as_posix() if file_path else None\n\n    def get_containers(self) -&gt; Generator[dict, None, list]:\n        \"\"\"Get containers from the current workfile.\n\n        Yields:\n            Generator: Container data.\n\n        \"\"\"\n        # sourcery skip: use-named-expression\n        data = self.get_ayon_data()\n        if data:\n            yield from data.get(MOCHA_CONTAINERS_KEY, [])\n        yield {}\n\n    def add_container(self, container: Container) -&gt; None:\n        \"\"\"Add a container to the current workfile.\n\n        Args:\n            container (Container): Container to add.\n\n        \"\"\"\n        data = self.get_ayon_data()\n        containers_dicts = list(self.get_containers())\n        containers = [\n            Container(**_container) for _container in containers_dicts\n        ]\n        to_remove = [\n            idx\n            for idx, _container in enumerate(containers)\n            if _container.name == container.name\n            and _container.namespace == container.namespace\n        ]\n        for idx in reversed(to_remove):\n            containers.pop(idx)\n\n        data[MOCHA_CONTAINERS_KEY] = [\n            *containers, dataclasses.asdict(container)]\n\n        self.update_ayon_data(data)\n\n    def remove_container(self, container: Container) -&gt; None:\n        \"\"\"Remove a container from the current workfile.\n\n        Args:\n            container (Container): Container to remove.\n\n        \"\"\"\n        data = self.get_ayon_data()\n        containers_dicts = list(self.get_containers())\n        containers = [\n            Container(**_container) for _container in containers_dicts\n        ]\n        to_remove = [\n            idx\n            for idx, _container in enumerate(containers)\n            if _container.name == container.name\n            and _container.namespace == container.namespace\n        ]\n        for idx in reversed(to_remove):\n            containers.pop(idx)\n\n        data[MOCHA_CONTAINERS_KEY] = [\n            dataclasses.asdict(_container) for _container in containers]\n\n        self.update_ayon_data(data)\n\n    def _create_ayon_data(self) -&gt; None:\n        \"\"\"Create AYON data in the current project.\"\"\"\n        project = self.get_current_project()\n        project.notes = (\n            f\"{project.notes}\\n\"\n            f\"{AYON_METADATA_GUARD}\\n\")\n\n    def get_ayon_data(self) -&gt; dict:\n        \"\"\"Get AYON context data from the current project.\n\n        Mocha Pro doesn't have any custom node or other\n        place to store metadata, so we store context data in\n        the project notes encoded as JSON and wrapped in a\n        special guard string `AYON_CONTEXT::...::AYON_CONTEXT_END`.\n\n        Returns:\n            dict: Context data.\n\n        \"\"\"\n        # sourcery skip: use-named-expression\n        project = self.get_current_project()\n        m = re.search(AYON_METADATA_REGEX, project.notes)\n        if not m:\n            self._create_ayon_data()\n            return {}\n        try:\n            context = json.loads(m[\"context\"]) if m else {}\n        except ValueError:\n            self.log.debug(\"AYON data is not valid json\")\n            # AYON data not found or invalid, create empty placeholder\n            self._create_ayon_data()\n            return {}\n\n        return context\n\n    def update_ayon_data(self, data: dict) -&gt; None:\n        \"\"\"Update AYON context data in the current project.\n\n        Serialize context data as json and store it in the\n        project notes. If the context data is not found, create\n        a placeholder there. See `get_context_data` for more info.\n\n        Args:\n            data (dict): Context data.\n\n        \"\"\"\n        project = self.get_current_project()\n        original_data = self.get_ayon_data()\n\n        updated_data = original_data.copy()\n        updated_data.update(data)\n        update_str = json.dumps(\n            updated_data or {}, indent=4, cls=AYONJSONEncoder)\n\n        project.notes = re.sub(\n                AYON_METADATA_REGEX,\n                AYON_METADATA_GUARD.format(update_str),\n                project.notes,\n            )\n        update_ui()\n\n    def get_context_data(self) -&gt; dict:\n        \"\"\"Get context data from the current project.\n\n        Returns:\n            dict: Context data.\n\n        \"\"\"\n        data = self.get_ayon_data()\n\n        return data.get(MOCHA_CONTEXT_KEY, {})\n\n    def update_context_data(\n            self, data: dict, changes: dict) -&gt; None:\n        \"\"\"Update context data in the current project.\n\n        Args:\n            data (dict): Context data.\n            changes (dict): Changes to the context data.\n\n        \"\"\"\n        if not data:\n            return\n        ayon_data = self.get_ayon_data()\n        ayon_data[MOCHA_CONTEXT_KEY] = data\n        self.update_ayon_data(ayon_data)\n\n    def get_publish_instances(self) -&gt; list[dict]:\n        \"\"\"Get publish instances from the current project.\n\n        Returns:\n            list[dict]: Publish instances.\n\n        \"\"\"\n        data = self.get_ayon_data()\n        return data.get(MOCHA_INSTANCES_KEY, [])\n\n    def add_publish_instance(self, instance_data: dict) -&gt; None:\n        \"\"\"Add a publish instance to the current project.\n\n        Args:\n            instance_data (dict): Publish instance to add.\n\n        \"\"\"\n        data = self.get_ayon_data()\n        publish_instances = self.get_publish_instances()\n        publish_instances.append(instance_data)\n        data[MOCHA_INSTANCES_KEY] = publish_instances\n\n        self.update_ayon_data(data)\n\n    def update_publish_instance(\n            self,\n            instance_id: str,\n            data: dict,\n    ) -&gt; None:\n        \"\"\"Update a publish instance in the current project.\n\n        Args:\n            instance_id (str): Publish instance id to update.\n            data (dict): Data to update.\n\n        \"\"\"\n        ayon_data = self.get_ayon_data()\n        publish_instances = self.get_publish_instances()\n        for idx, publish_instance in enumerate(publish_instances):\n            if publish_instance[\"instance_id\"] == instance_id:\n                publish_instances[idx] = data\n                break\n        ayon_data[MOCHA_INSTANCES_KEY] = publish_instances\n\n        self.update_ayon_data(ayon_data)\n\n    def write_create_instances(\n            self, instances: list[dict]) -&gt; None:\n        \"\"\"Write publish instances to the current project.\"\"\"\n        ayon_data = self.get_ayon_data()\n        ayon_data[MOCHA_INSTANCES_KEY] = instances\n        self.update_ayon_data(ayon_data)\n\n    def remove_create_instance(self, instance_id: str) -&gt; None:\n        \"\"\"Remove a publishing instance from the current project.\n\n        Args:\n            instance_id (str): Publish instance id to remove.\n\n        \"\"\"\n        data = self.get_ayon_data()\n        publish_instances = self.get_publish_instances()\n        publish_instances = [\n            publish_instance\n            for publish_instance in publish_instances\n            if publish_instance[\"instance_id\"] != instance_id\n        ]\n        data[MOCHA_INSTANCES_KEY] = publish_instances\n\n        self.update_ayon_data(data)\n\n    def get_current_project(self) -&gt; Project:\n        \"\"\"Return the current project.\"\"\"\n        project = _get_current_project()\n        if not project:\n            if not self._uninitialized_project_warning_shown:\n                show_message_dialog(\n                    \"No project is opened.\",\n                    (\n                        \"Please open or save a project first, otherwise \"\n                        \"you won't be able to see the results of any \"\n                        \"operations you'll make.\"\n                    ),\n                    parent=get_main_window(),\n                )\n                self._uninitialized_project_warning_shown = True\n            return create_empty_project()\n        return project\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/index.html#client.ayon_mocha.api.MochaProHost.add_container","title":"<code>add_container(container)</code>","text":"<p>Add a container to the current workfile.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>Container</code> <p>Container to add.</p> required Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def add_container(self, container: Container) -&gt; None:\n    \"\"\"Add a container to the current workfile.\n\n    Args:\n        container (Container): Container to add.\n\n    \"\"\"\n    data = self.get_ayon_data()\n    containers_dicts = list(self.get_containers())\n    containers = [\n        Container(**_container) for _container in containers_dicts\n    ]\n    to_remove = [\n        idx\n        for idx, _container in enumerate(containers)\n        if _container.name == container.name\n        and _container.namespace == container.namespace\n    ]\n    for idx in reversed(to_remove):\n        containers.pop(idx)\n\n    data[MOCHA_CONTAINERS_KEY] = [\n        *containers, dataclasses.asdict(container)]\n\n    self.update_ayon_data(data)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/index.html#client.ayon_mocha.api.MochaProHost.add_publish_instance","title":"<code>add_publish_instance(instance_data)</code>","text":"<p>Add a publish instance to the current project.</p> <p>Parameters:</p> Name Type Description Default <code>instance_data</code> <code>dict</code> <p>Publish instance to add.</p> required Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def add_publish_instance(self, instance_data: dict) -&gt; None:\n    \"\"\"Add a publish instance to the current project.\n\n    Args:\n        instance_data (dict): Publish instance to add.\n\n    \"\"\"\n    data = self.get_ayon_data()\n    publish_instances = self.get_publish_instances()\n    publish_instances.append(instance_data)\n    data[MOCHA_INSTANCES_KEY] = publish_instances\n\n    self.update_ayon_data(data)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/index.html#client.ayon_mocha.api.MochaProHost.get_ayon_data","title":"<code>get_ayon_data()</code>","text":"<p>Get AYON context data from the current project.</p> <p>Mocha Pro doesn't have any custom node or other place to store metadata, so we store context data in the project notes encoded as JSON and wrapped in a special guard string <code>AYON_CONTEXT::...::AYON_CONTEXT_END</code>.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Context data.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def get_ayon_data(self) -&gt; dict:\n    \"\"\"Get AYON context data from the current project.\n\n    Mocha Pro doesn't have any custom node or other\n    place to store metadata, so we store context data in\n    the project notes encoded as JSON and wrapped in a\n    special guard string `AYON_CONTEXT::...::AYON_CONTEXT_END`.\n\n    Returns:\n        dict: Context data.\n\n    \"\"\"\n    # sourcery skip: use-named-expression\n    project = self.get_current_project()\n    m = re.search(AYON_METADATA_REGEX, project.notes)\n    if not m:\n        self._create_ayon_data()\n        return {}\n    try:\n        context = json.loads(m[\"context\"]) if m else {}\n    except ValueError:\n        self.log.debug(\"AYON data is not valid json\")\n        # AYON data not found or invalid, create empty placeholder\n        self._create_ayon_data()\n        return {}\n\n    return context\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/index.html#client.ayon_mocha.api.MochaProHost.get_containers","title":"<code>get_containers()</code>","text":"<p>Get containers from the current workfile.</p> <p>Yields:</p> Name Type Description <code>Generator</code> <code>dict</code> <p>Container data.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def get_containers(self) -&gt; Generator[dict, None, list]:\n    \"\"\"Get containers from the current workfile.\n\n    Yields:\n        Generator: Container data.\n\n    \"\"\"\n    # sourcery skip: use-named-expression\n    data = self.get_ayon_data()\n    if data:\n        yield from data.get(MOCHA_CONTAINERS_KEY, [])\n    yield {}\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/index.html#client.ayon_mocha.api.MochaProHost.get_context_data","title":"<code>get_context_data()</code>","text":"<p>Get context data from the current project.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Context data.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def get_context_data(self) -&gt; dict:\n    \"\"\"Get context data from the current project.\n\n    Returns:\n        dict: Context data.\n\n    \"\"\"\n    data = self.get_ayon_data()\n\n    return data.get(MOCHA_CONTEXT_KEY, {})\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/index.html#client.ayon_mocha.api.MochaProHost.get_current_project","title":"<code>get_current_project()</code>","text":"<p>Return the current project.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def get_current_project(self) -&gt; Project:\n    \"\"\"Return the current project.\"\"\"\n    project = _get_current_project()\n    if not project:\n        if not self._uninitialized_project_warning_shown:\n            show_message_dialog(\n                \"No project is opened.\",\n                (\n                    \"Please open or save a project first, otherwise \"\n                    \"you won't be able to see the results of any \"\n                    \"operations you'll make.\"\n                ),\n                parent=get_main_window(),\n            )\n            self._uninitialized_project_warning_shown = True\n        return create_empty_project()\n    return project\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/index.html#client.ayon_mocha.api.MochaProHost.get_current_workfile","title":"<code>get_current_workfile()</code>","text":"<p>Get the current workfile.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The current workfile.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def get_current_workfile(self) -&gt; Optional[str]:  # noqa: PLR6301\n    \"\"\"Get the current workfile.\n\n    Returns:\n        Optional[str]: The current workfile.\n\n    \"\"\"\n    file_path = current_file()\n    return file_path.as_posix() if file_path else None\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/index.html#client.ayon_mocha.api.MochaProHost.get_publish_instances","title":"<code>get_publish_instances()</code>","text":"<p>Get publish instances from the current project.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: Publish instances.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def get_publish_instances(self) -&gt; list[dict]:\n    \"\"\"Get publish instances from the current project.\n\n    Returns:\n        list[dict]: Publish instances.\n\n    \"\"\"\n    data = self.get_ayon_data()\n    return data.get(MOCHA_INSTANCES_KEY, [])\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/index.html#client.ayon_mocha.api.MochaProHost.get_workfile_extensions","title":"<code>get_workfile_extensions()</code>","text":"<p>Get the workfile extensions.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Workfile extensions.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def get_workfile_extensions(self) -&gt; list[str]:  # noqa: PLR6301\n    \"\"\"Get the workfile extensions.\n\n    Returns:\n        list[str]: Workfile extensions.\n\n    \"\"\"\n    return file_extensions()\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/index.html#client.ayon_mocha.api.MochaProHost.install","title":"<code>install()</code>","text":"<p>Initialize the host.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def install(self) -&gt; None:\n    \"\"\"Initialize the host.\"\"\"\n    pyblish.api.register_host(self.name)\n    pyblish.api.register_plugin_path(PUBLISH_PATH.as_posix())\n    register_loader_plugin_path(LOAD_PATH.as_posix())\n    register_creator_plugin_path(CREATE_PATH.as_posix())\n\n    # QtCore.QTimer.singleShot(0, self._install_menu)\n    self._install_menu()\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/index.html#client.ayon_mocha.api.MochaProHost.open_workfile","title":"<code>open_workfile(filepath)</code>","text":"<p>Open the workfile.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def open_workfile(self, filepath: str) -&gt; None:  # noqa: PLR6301\n    \"\"\"Open the workfile.\"\"\"\n    open_file(Path(filepath))\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/index.html#client.ayon_mocha.api.MochaProHost.remove_container","title":"<code>remove_container(container)</code>","text":"<p>Remove a container from the current workfile.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>Container</code> <p>Container to remove.</p> required Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def remove_container(self, container: Container) -&gt; None:\n    \"\"\"Remove a container from the current workfile.\n\n    Args:\n        container (Container): Container to remove.\n\n    \"\"\"\n    data = self.get_ayon_data()\n    containers_dicts = list(self.get_containers())\n    containers = [\n        Container(**_container) for _container in containers_dicts\n    ]\n    to_remove = [\n        idx\n        for idx, _container in enumerate(containers)\n        if _container.name == container.name\n        and _container.namespace == container.namespace\n    ]\n    for idx in reversed(to_remove):\n        containers.pop(idx)\n\n    data[MOCHA_CONTAINERS_KEY] = [\n        dataclasses.asdict(_container) for _container in containers]\n\n    self.update_ayon_data(data)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/index.html#client.ayon_mocha.api.MochaProHost.remove_create_instance","title":"<code>remove_create_instance(instance_id)</code>","text":"<p>Remove a publishing instance from the current project.</p> <p>Parameters:</p> Name Type Description Default <code>instance_id</code> <code>str</code> <p>Publish instance id to remove.</p> required Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def remove_create_instance(self, instance_id: str) -&gt; None:\n    \"\"\"Remove a publishing instance from the current project.\n\n    Args:\n        instance_id (str): Publish instance id to remove.\n\n    \"\"\"\n    data = self.get_ayon_data()\n    publish_instances = self.get_publish_instances()\n    publish_instances = [\n        publish_instance\n        for publish_instance in publish_instances\n        if publish_instance[\"instance_id\"] != instance_id\n    ]\n    data[MOCHA_INSTANCES_KEY] = publish_instances\n\n    self.update_ayon_data(data)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/index.html#client.ayon_mocha.api.MochaProHost.save_workfile","title":"<code>save_workfile(dst_path=None)</code>","text":"<p>Save the workfile.</p> <p>Parameters:</p> Name Type Description Default <code>dst_path</code> <code>str</code> <p>The destination path to save the file to. Defaults to None.</p> <code>None</code> <p>Todo (antirotor): This needs to display error if the project     isn't initialized yet.     https://github.com/ynput/ayon-core/issues/1075</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def save_workfile(self, dst_path: Optional[str] = None) -&gt; None:  # noqa: PLR6301\n    \"\"\"Save the workfile.\n\n    Args:\n        dst_path (str, optional): The destination path to save the file to.\n            Defaults to None.\n\n    Todo (antirotor): This needs to display error if the project\n        isn't initialized yet.\n        https://github.com/ynput/ayon-core/issues/1075\n\n    \"\"\"\n    if dst_path:\n        save_file(Path(dst_path))\n    else:\n        save_file(filepath=None)\n    if not _get_current_project():\n        reset_frame_range(_get_current_project())\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/index.html#client.ayon_mocha.api.MochaProHost.update_ayon_data","title":"<code>update_ayon_data(data)</code>","text":"<p>Update AYON context data in the current project.</p> <p>Serialize context data as json and store it in the project notes. If the context data is not found, create a placeholder there. See <code>get_context_data</code> for more info.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Context data.</p> required Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def update_ayon_data(self, data: dict) -&gt; None:\n    \"\"\"Update AYON context data in the current project.\n\n    Serialize context data as json and store it in the\n    project notes. If the context data is not found, create\n    a placeholder there. See `get_context_data` for more info.\n\n    Args:\n        data (dict): Context data.\n\n    \"\"\"\n    project = self.get_current_project()\n    original_data = self.get_ayon_data()\n\n    updated_data = original_data.copy()\n    updated_data.update(data)\n    update_str = json.dumps(\n        updated_data or {}, indent=4, cls=AYONJSONEncoder)\n\n    project.notes = re.sub(\n            AYON_METADATA_REGEX,\n            AYON_METADATA_GUARD.format(update_str),\n            project.notes,\n        )\n    update_ui()\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/index.html#client.ayon_mocha.api.MochaProHost.update_context_data","title":"<code>update_context_data(data, changes)</code>","text":"<p>Update context data in the current project.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Context data.</p> required <code>changes</code> <code>dict</code> <p>Changes to the context data.</p> required Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def update_context_data(\n        self, data: dict, changes: dict) -&gt; None:\n    \"\"\"Update context data in the current project.\n\n    Args:\n        data (dict): Context data.\n        changes (dict): Changes to the context data.\n\n    \"\"\"\n    if not data:\n        return\n    ayon_data = self.get_ayon_data()\n    ayon_data[MOCHA_CONTEXT_KEY] = data\n    self.update_ayon_data(ayon_data)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/index.html#client.ayon_mocha.api.MochaProHost.update_publish_instance","title":"<code>update_publish_instance(instance_id, data)</code>","text":"<p>Update a publish instance in the current project.</p> <p>Parameters:</p> Name Type Description Default <code>instance_id</code> <code>str</code> <p>Publish instance id to update.</p> required <code>data</code> <code>dict</code> <p>Data to update.</p> required Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def update_publish_instance(\n        self,\n        instance_id: str,\n        data: dict,\n) -&gt; None:\n    \"\"\"Update a publish instance in the current project.\n\n    Args:\n        instance_id (str): Publish instance id to update.\n        data (dict): Data to update.\n\n    \"\"\"\n    ayon_data = self.get_ayon_data()\n    publish_instances = self.get_publish_instances()\n    for idx, publish_instance in enumerate(publish_instances):\n        if publish_instance[\"instance_id\"] == instance_id:\n            publish_instances[idx] = data\n            break\n    ayon_data[MOCHA_INSTANCES_KEY] = publish_instances\n\n    self.update_ayon_data(ayon_data)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/index.html#client.ayon_mocha.api.MochaProHost.write_create_instances","title":"<code>write_create_instances(instances)</code>","text":"<p>Write publish instances to the current project.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def write_create_instances(\n        self, instances: list[dict]) -&gt; None:\n    \"\"\"Write publish instances to the current project.\"\"\"\n    ayon_data = self.get_ayon_data()\n    ayon_data[MOCHA_INSTANCES_KEY] = instances\n    self.update_ayon_data(ayon_data)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/lib.html","title":"lib","text":"<p>Library functions for the Ayon Mocha API.</p>"},{"location":"autoapi/client/ayon_mocha/api/lib.html#client.ayon_mocha.api.lib.EXTENSION_PATTERN","title":"<code>EXTENSION_PATTERN = re.compile('(?P&lt;name&gt;.+)\\\\(\\\\*\\\\.(?P&lt;ext&gt;\\\\w+)\\\\)')</code>  <code>module-attribute</code>","text":"<p>These dataclasses are here because they cannot be defined directly in pyblish plugins. There seems to be an issue (at least in python 3.7) with dataclass checking for module in class and that one is missing in discovered pyblish plugin classes.</p>"},{"location":"autoapi/client/ayon_mocha/api/lib.html#client.ayon_mocha.api.lib.ExporterInfo","title":"<code>ExporterInfo</code>  <code>dataclass</code>","text":"<p>Exporter information.</p> Source code in <code>client/ayon_mocha/api/lib.py</code> <pre><code>@dataclasses.dataclass\nclass ExporterInfo:\n    \"\"\"Exporter information.\"\"\"\n    id: str\n    label: str\n    exporter: Union[TrackingDataExporter, ShapeDataExporter]\n    short_name: str\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/lib.html#client.ayon_mocha.api.lib.ExporterProcessInfo","title":"<code>ExporterProcessInfo</code>  <code>dataclass</code>","text":"<p>Exporter process information.</p> Source code in <code>client/ayon_mocha/api/lib.py</code> <pre><code>@dataclasses.dataclass\nclass ExporterProcessInfo:\n    \"\"\"Exporter process information.\"\"\"\n    mocha_python_path: Path\n    mocha_exporter_path: Path\n    current_project_path: Path\n    staging_dir: Path\n    options: dict[str, bool]\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/lib.html#client.ayon_mocha.api.lib.copy_placeholder_clip","title":"<code>copy_placeholder_clip(destination)</code>","text":"<p>Copy placeholder clip to the destination.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <code>Path</code> <p>Destination directory.</p> required <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Path to the copied clip.</p> Source code in <code>client/ayon_mocha/api/lib.py</code> <pre><code>def copy_placeholder_clip(destination: Path) -&gt; Path:\n    \"\"\"Copy placeholder clip to the destination.\n\n    Args:\n        destination (Path): Destination directory.\n\n    Returns:\n        Path: Path to the copied clip.\n\n    \"\"\"\n    clip_path = destination / \"empty.exr\"\n    copyfile(\n        Path(MOCHA_ADDON_ROOT) / \"resources\" / \"empty.exr\",\n        clip_path\n    )\n    return clip_path\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/lib.html#client.ayon_mocha.api.lib.create_empty_project","title":"<code>create_empty_project(project_path=None)</code>","text":"<p>Create an empty project.</p> <p>Parameters:</p> Name Type Description Default <code>project_path</code> <code>Path</code> <p>Project path. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Project</code> <code>Project</code> <p>Project instance.</p> Source code in <code>client/ayon_mocha/api/lib.py</code> <pre><code>def create_empty_project(\n        project_path: Optional[Path] = None) -&gt; Project:\n    \"\"\"Create an empty project.\n\n    Args:\n        project_path (Path, optional): Project path. Defaults to None.\n\n    Returns:\n        Project: Project instance.\n\n    \"\"\"\n    if not project_path:\n        project_path = Path(tempfile.NamedTemporaryFile(  # noqa: SIM115\n            suffix=\".mocha\", delete=False).name)\n\n    clip_path = copy_placeholder_clip(project_path.parent)\n    clip = Clip(clip_path.as_posix())\n    return Project(clip)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/lib.html#client.ayon_mocha.api.lib.get_main_window","title":"<code>get_main_window()</code>","text":"<p>Get the main window of the application.</p> <p>Returns:</p> Name Type Description <code>QWidget</code> <code>QWidget</code> <p>Main window of the application.</p> Source code in <code>client/ayon_mocha/api/lib.py</code> <pre><code>def get_main_window() -&gt; QtWidgets.QWidget:\n    \"\"\"Get the main window of the application.\n\n    Returns:\n        QWidget: Main window of the application.\n    \"\"\"\n    return ui.get_widgets()[\"MainWindow\"]\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/lib.html#client.ayon_mocha.api.lib.get_mocha_version","title":"<code>get_mocha_version()</code>","text":"<p>Return Mocha version.</p> Source code in <code>client/ayon_mocha/api/lib.py</code> <pre><code>def get_mocha_version() -&gt; Optional[str]:\n    \"\"\"Return Mocha version.\"\"\"\n    app_name = REGISTRY_APPLICATION_NAME\n    result = re.search(\n        r\"Mocha Pro (?P&lt;version&gt;\\d+\\.?\\d+)\", app_name)\n    return result[\"version\"] if result else None\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/lib.html#client.ayon_mocha.api.lib.get_shape_exporters","title":"<code>get_shape_exporters()</code>","text":"<p>Return all registered shape exporters as a list.</p> Source code in <code>client/ayon_mocha/api/lib.py</code> <pre><code>def get_shape_exporters() -&gt; list[ExporterInfo]:\n    \"\"\"Return all registered shape exporters as a list.\"\"\"\n    version = get_mocha_version() or \"2024\"\n    try:\n        mapping = EXPORTER_MAPPING[\"shape\"][version]\n    except KeyError:\n        mapping = EXPORTER_MAPPING[\"shape\"][\"2024.5\"]\n\n    return [\n        ExporterInfo(\n            id=sha256(k.encode()).hexdigest(),\n            label=k,\n            exporter=v,\n            short_name=mapping.get(k, k)\n        )\n        for k, v in sorted(\n            ShapeDataExporter.registered_exporters().items())\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/lib.html#client.ayon_mocha.api.lib.get_tracking_exporters","title":"<code>get_tracking_exporters()</code>","text":"<p>Return all registered exporters as a list.</p> Source code in <code>client/ayon_mocha/api/lib.py</code> <pre><code>def get_tracking_exporters() -&gt; list[ExporterInfo]:\n    \"\"\"Return all registered exporters as a list.\"\"\"\n    version = get_mocha_version() or \"2024\"\n    try:\n        mapping = EXPORTER_MAPPING[\"tracking\"][version]\n    except KeyError:\n        mapping = EXPORTER_MAPPING[\"tracking\"][\"2024.5\"]\n\n    return [\n        ExporterInfo(\n            id=sha256(k.encode()).hexdigest(),\n            label=k,\n            exporter=v,\n            short_name=mapping.get(k, k))\n        for k, v in sorted(\n            TrackingDataExporter.registered_exporters().items())\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/lib.html#client.ayon_mocha.api.lib.quit_mocha","title":"<code>quit_mocha()</code>","text":"<p>Quit Mocha application.</p> Source code in <code>client/ayon_mocha/api/lib.py</code> <pre><code>def quit_mocha() -&gt; None:\n    \"\"\"Quit Mocha application.\"\"\"\n    # this code unfortunately doesn't work\n    # menu_file = ui.get_menus()[\"MenuFile\"]\n    # quit_action = next(\n    #   filter(lambda a: a.objectName() == \"FileExit\", menu_file.actions()))\n    # quit_action.triggered.emit()\n    # so we need to use this workaround\n    QApplication.instance().quit()\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/lib.html#client.ayon_mocha.api.lib.run_mocha","title":"<code>run_mocha(app='mochapro', footage_path='', **kwargs)</code>","text":"<p>Run Mocha application with given command-line arguments.</p> <p>See https://borisfx.com/support/documentation/mocha/#_command_line</p> <p>This is modified version of the original function from mocha module. We need to pass the environment to the subprocess.Popen call.</p> Todo <ul> <li>return something so we quit the parent app only if the new     app is running</li> <li>refactor this function to use the subprocess.run function</li> </ul> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>str</code> <p>Application name (without an extension).</p> <code>'mochapro'</code> <code>footage_path</code> <code>str</code> <p>An absolute path to footage file.</p> <code>''</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments for command line.</p> <code>{}</code> <p>Keywords mapping::</p> <pre><code>in_point =&gt; --in\nout_point =&gt; --out\nframe_rate =&gt; --frame-rate\npar =&gt; --par\ninterlace_mode =&gt; --interlace-mode\n</code></pre> <p>Raises:</p> Type Description <code>ValueError</code> <p>If unknown keyword argument is passed.</p> Source code in <code>client/ayon_mocha/api/lib.py</code> <pre><code>def run_mocha(\n        app: str = \"mochapro\",\n        footage_path: str = \"\",\n        **kwargs: dict[str, Any]) -&gt; None:\n    \"\"\"Run Mocha application with given command-line arguments.\n\n    See https://borisfx.com/support/documentation/mocha/#_command_line\n\n    This is modified version of the original function from mocha module.\n    We need to pass the environment to the subprocess.Popen call.\n\n    Todo:\n        - return something so we quit the parent app only if the new\n            app is running\n        - refactor this function to use the subprocess.run function\n\n    Args:\n        app (str): Application name (without an extension).\n        footage_path (str): An absolute path to footage file.\n        **kwargs: Keyword arguments for command line.\n\n    Keywords mapping::\n\n        in_point =&gt; --in\n        out_point =&gt; --out\n        frame_rate =&gt; --frame-rate\n        par =&gt; --par\n        interlace_mode =&gt; --interlace-mode\n\n    Raises:\n        ValueError: If unknown keyword argument is passed.\n\n    \"\"\"\n    import os\n    mocha_path = get_mocha_exec_name(app)\n    if not os.path.isfile(mocha_path):\n        return\n\n    available_args = {\n        \"in_point\": \"in\",\n        \"out_point\": \"out\",\n        \"frame_rate\": \"frame-rate\",\n        \"par\": \"par\",\n        \"interlace_mode\": \"interlace-mode\"\n    }\n    available_keys = set(available_args.keys())\n    current_keys = set(kwargs.keys())\n    if not current_keys &lt;= available_keys:\n        msg = (\n            \"No such parameters: \"\n            \", \".join(current_keys - available_keys)\n        )\n        raise ValueError(msg)\n\n    cmd_args: list[str] = []\n    for key, value in kwargs.items():\n        cmd_args.extend((f\"--{available_args[key]}\", str(value)))\n    cmd = [mocha_path, *cmd_args]\n    if footage_path:\n        cmd.append(footage_path)\n\n    env = os.environ.copy()\n    env[\"PYTHONPATH\"] = os.pathsep.join(sys.path)\n    if os.name == \"nt\":\n        p = subprocess.Popen(\n            cmd, creationflags=0x00000008, close_fds=True, env=env)\n    else:\n        p = subprocess.Popen(\n            cmd, close_fds=True, env=env)\n    p.poll()\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/lib.html#client.ayon_mocha.api.lib.sanitize_unknown_exporter_name","title":"<code>sanitize_unknown_exporter_name(name)</code>","text":"<p>Sanitize unknown exporter name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Exporter name.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Sanitized exporter name</p> Source code in <code>client/ayon_mocha/api/lib.py</code> <pre><code>def sanitize_unknown_exporter_name(name: str) -&gt; str:\n    \"\"\"Sanitize unknown exporter name.\n\n    Args:\n        name (str): Exporter name.\n\n    Returns:\n        str: Sanitized exporter name\n\n    \"\"\"\n    return re.sub(r\"[^a-zA-Z0-9]\", \"_\", name)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/lib.html#client.ayon_mocha.api.lib.update_ui","title":"<code>update_ui()</code>","text":"<p>Update the UI.</p> Source code in <code>client/ayon_mocha/api/lib.py</code> <pre><code>def update_ui() -&gt; None:\n    \"\"\"Update the UI.\"\"\"\n    QApplication.processEvents()\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/mocha_exporter_mappings.html","title":"mocha_exporter_mappings","text":"<p>Exporters representation name mappings for Mocha.</p> <p>This is a mapping of representation names to exporter ids as the representation name has limits both in how it is now displayed in the UI and how it is stored in the project - it is a string without spaces and special characters. It must be updated now and then to keep it in sync with the actual Mocha exporting capabilities.</p>"},{"location":"autoapi/client/ayon_mocha/api/pipeline.html","title":"pipeline","text":"<p>Mocha Pro AYON pipeline API.</p> Notes <p>PLR6301 (can be static method, class method or function) is used there because the parent class <code>IWorkfileHost</code> has different signatures.</p>"},{"location":"autoapi/client/ayon_mocha/api/pipeline.html#client.ayon_mocha.api.pipeline.AYONJSONEncoder","title":"<code>AYONJSONEncoder</code>","text":"<p>               Bases: <code>JSONEncoder</code></p> <p>Custom JSON encoder for dataclasses.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>class AYONJSONEncoder(json.JSONEncoder):\n    \"\"\"Custom JSON encoder for dataclasses.\"\"\"\n\n    def default(self, obj: object) -&gt; Union[dict, object]:\n        \"\"\"Encode dataclasses as dict.\n\n        Args:\n            obj (object): Object to encode.\n\n        Returns:\n            Union[dict, object]: Encoded object.\n\n        \"\"\"\n        if dataclasses.is_dataclass(obj):\n            return dataclasses.asdict(obj)  # type: ignore[arg-type]\n        if isinstance(obj, CreatedInstance):\n            return dict(obj)\n        return super().default(obj)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/pipeline.html#client.ayon_mocha.api.pipeline.AYONJSONEncoder.default","title":"<code>default(obj)</code>","text":"<p>Encode dataclasses as dict.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>Object to encode.</p> required <p>Returns:</p> Type Description <code>Union[dict, object]</code> <p>Union[dict, object]: Encoded object.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def default(self, obj: object) -&gt; Union[dict, object]:\n    \"\"\"Encode dataclasses as dict.\n\n    Args:\n        obj (object): Object to encode.\n\n    Returns:\n        Union[dict, object]: Encoded object.\n\n    \"\"\"\n    if dataclasses.is_dataclass(obj):\n        return dataclasses.asdict(obj)  # type: ignore[arg-type]\n    if isinstance(obj, CreatedInstance):\n        return dict(obj)\n    return super().default(obj)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/pipeline.html#client.ayon_mocha.api.pipeline.Container","title":"<code>Container</code>  <code>dataclass</code>","text":"<p>Container data class.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>@dataclasses.dataclass\nclass Container:\n    \"\"\"Container data class.\"\"\"\n\n    name: Optional[str] = None\n    id: str = AYON_CONTAINER_ID\n    namespace: str = \"\"\n    loader: Optional[str] = None\n    representation: Optional[str] = None\n    objectName: Optional[str] = None  # noqa: N815\n    timestamp: int = 0\n    version: Optional[str] = None\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/pipeline.html#client.ayon_mocha.api.pipeline.MochaProHost","title":"<code>MochaProHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> <p>Mocha Pro host implementation.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>class MochaProHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n    \"\"\"Mocha Pro host implementation.\"\"\"\n\n    name = \"mochapro\"\n    _uninitialized_project_warning_shown = False\n\n    def install(self) -&gt; None:\n        \"\"\"Initialize the host.\"\"\"\n        pyblish.api.register_host(self.name)\n        pyblish.api.register_plugin_path(PUBLISH_PATH.as_posix())\n        register_loader_plugin_path(LOAD_PATH.as_posix())\n        register_creator_plugin_path(CREATE_PATH.as_posix())\n\n        # QtCore.QTimer.singleShot(0, self._install_menu)\n        self._install_menu()\n\n    def _install_menu(self) -&gt; None:\n        \"\"\"Install the menu.\"\"\"\n        main_window = get_main_window()\n\n        menu_label = os.getenv(\"AYON_MENU_LABEL\", \"AYON\")\n        menu = main_window.menuBar().addMenu(menu_label)\n\n        action = menu.addAction(\"Current Context\")\n\n        def _on_menu_about_to_show(menu_action: QtWidgets.QAction) -&gt; None:\n            \"\"\"Update the menu.\"\"\"\n            context = self.get_current_context()\n            menu_action.setText(\n                f\"{context['folder_path']}, {context['task_name']}\")\n\n        action.setEnabled(False)\n        menu.aboutToShow.connect(partial(_on_menu_about_to_show, action))\n        menu.addSeparator()\n\n        action = menu.addAction(\"Create...\")\n        action.triggered.connect(\n            lambda: host_tools.show_publisher(\n                parent=main_window, tab=\"create\"))\n\n        action = menu.addAction(\"Load...\")\n        action.triggered.connect(\n            lambda: host_tools.show_loader(\n                parent=main_window, use_context=True))\n\n        action = menu.addAction(\"Publish...\")\n        action.triggered.connect(\n            lambda: host_tools.show_publisher(\n                parent=main_window, tab=\"publish\"))\n\n        action = menu.addAction(\"Manage...\")\n        action.triggered.connect(\n            lambda: host_tools.show_scene_inventory(parent=main_window))\n\n        action = menu.addAction(\"Library...\")\n        action.triggered.connect(\n            lambda: host_tools.show_library_loader(parent=main_window))\n\n        menu.addSeparator()\n\n        action = menu.addAction(\"Work Files...\")\n        action.triggered.connect(\n            lambda: host_tools.show_workfiles(parent=main_window))\n\n        menu.addSeparator()\n\n        action = menu.addAction(\"Reset Frame Range and FPS\")\n        action.triggered.connect(\n            lambda: reset_frame_range(self.get_current_project()))\n\n        menu.addSeparator()\n\n        action = menu.addAction(\"Experimental Tools...\")\n        action.triggered.connect(\n            lambda: host_tools.show_experimental_tools_dialog(\n                parent=main_window))\n\n    def get_workfile_extensions(self) -&gt; list[str]:  # noqa: PLR6301\n        \"\"\"Get the workfile extensions.\n\n        Returns:\n            list[str]: Workfile extensions.\n\n        \"\"\"\n        return file_extensions()\n\n    def save_workfile(self, dst_path: Optional[str] = None) -&gt; None:  # noqa: PLR6301\n        \"\"\"Save the workfile.\n\n        Args:\n            dst_path (str, optional): The destination path to save the file to.\n                Defaults to None.\n\n        Todo (antirotor): This needs to display error if the project\n            isn't initialized yet.\n            https://github.com/ynput/ayon-core/issues/1075\n\n        \"\"\"\n        if dst_path:\n            save_file(Path(dst_path))\n        else:\n            save_file(filepath=None)\n        if not _get_current_project():\n            reset_frame_range(_get_current_project())\n\n    def open_workfile(self, filepath: str) -&gt; None:  # noqa: PLR6301\n        \"\"\"Open the workfile.\"\"\"\n        open_file(Path(filepath))\n\n    def get_current_workfile(self) -&gt; Optional[str]:  # noqa: PLR6301\n        \"\"\"Get the current workfile.\n\n        Returns:\n            Optional[str]: The current workfile.\n\n        \"\"\"\n        file_path = current_file()\n        return file_path.as_posix() if file_path else None\n\n    def get_containers(self) -&gt; Generator[dict, None, list]:\n        \"\"\"Get containers from the current workfile.\n\n        Yields:\n            Generator: Container data.\n\n        \"\"\"\n        # sourcery skip: use-named-expression\n        data = self.get_ayon_data()\n        if data:\n            yield from data.get(MOCHA_CONTAINERS_KEY, [])\n        yield {}\n\n    def add_container(self, container: Container) -&gt; None:\n        \"\"\"Add a container to the current workfile.\n\n        Args:\n            container (Container): Container to add.\n\n        \"\"\"\n        data = self.get_ayon_data()\n        containers_dicts = list(self.get_containers())\n        containers = [\n            Container(**_container) for _container in containers_dicts\n        ]\n        to_remove = [\n            idx\n            for idx, _container in enumerate(containers)\n            if _container.name == container.name\n            and _container.namespace == container.namespace\n        ]\n        for idx in reversed(to_remove):\n            containers.pop(idx)\n\n        data[MOCHA_CONTAINERS_KEY] = [\n            *containers, dataclasses.asdict(container)]\n\n        self.update_ayon_data(data)\n\n    def remove_container(self, container: Container) -&gt; None:\n        \"\"\"Remove a container from the current workfile.\n\n        Args:\n            container (Container): Container to remove.\n\n        \"\"\"\n        data = self.get_ayon_data()\n        containers_dicts = list(self.get_containers())\n        containers = [\n            Container(**_container) for _container in containers_dicts\n        ]\n        to_remove = [\n            idx\n            for idx, _container in enumerate(containers)\n            if _container.name == container.name\n            and _container.namespace == container.namespace\n        ]\n        for idx in reversed(to_remove):\n            containers.pop(idx)\n\n        data[MOCHA_CONTAINERS_KEY] = [\n            dataclasses.asdict(_container) for _container in containers]\n\n        self.update_ayon_data(data)\n\n    def _create_ayon_data(self) -&gt; None:\n        \"\"\"Create AYON data in the current project.\"\"\"\n        project = self.get_current_project()\n        project.notes = (\n            f\"{project.notes}\\n\"\n            f\"{AYON_METADATA_GUARD}\\n\")\n\n    def get_ayon_data(self) -&gt; dict:\n        \"\"\"Get AYON context data from the current project.\n\n        Mocha Pro doesn't have any custom node or other\n        place to store metadata, so we store context data in\n        the project notes encoded as JSON and wrapped in a\n        special guard string `AYON_CONTEXT::...::AYON_CONTEXT_END`.\n\n        Returns:\n            dict: Context data.\n\n        \"\"\"\n        # sourcery skip: use-named-expression\n        project = self.get_current_project()\n        m = re.search(AYON_METADATA_REGEX, project.notes)\n        if not m:\n            self._create_ayon_data()\n            return {}\n        try:\n            context = json.loads(m[\"context\"]) if m else {}\n        except ValueError:\n            self.log.debug(\"AYON data is not valid json\")\n            # AYON data not found or invalid, create empty placeholder\n            self._create_ayon_data()\n            return {}\n\n        return context\n\n    def update_ayon_data(self, data: dict) -&gt; None:\n        \"\"\"Update AYON context data in the current project.\n\n        Serialize context data as json and store it in the\n        project notes. If the context data is not found, create\n        a placeholder there. See `get_context_data` for more info.\n\n        Args:\n            data (dict): Context data.\n\n        \"\"\"\n        project = self.get_current_project()\n        original_data = self.get_ayon_data()\n\n        updated_data = original_data.copy()\n        updated_data.update(data)\n        update_str = json.dumps(\n            updated_data or {}, indent=4, cls=AYONJSONEncoder)\n\n        project.notes = re.sub(\n                AYON_METADATA_REGEX,\n                AYON_METADATA_GUARD.format(update_str),\n                project.notes,\n            )\n        update_ui()\n\n    def get_context_data(self) -&gt; dict:\n        \"\"\"Get context data from the current project.\n\n        Returns:\n            dict: Context data.\n\n        \"\"\"\n        data = self.get_ayon_data()\n\n        return data.get(MOCHA_CONTEXT_KEY, {})\n\n    def update_context_data(\n            self, data: dict, changes: dict) -&gt; None:\n        \"\"\"Update context data in the current project.\n\n        Args:\n            data (dict): Context data.\n            changes (dict): Changes to the context data.\n\n        \"\"\"\n        if not data:\n            return\n        ayon_data = self.get_ayon_data()\n        ayon_data[MOCHA_CONTEXT_KEY] = data\n        self.update_ayon_data(ayon_data)\n\n    def get_publish_instances(self) -&gt; list[dict]:\n        \"\"\"Get publish instances from the current project.\n\n        Returns:\n            list[dict]: Publish instances.\n\n        \"\"\"\n        data = self.get_ayon_data()\n        return data.get(MOCHA_INSTANCES_KEY, [])\n\n    def add_publish_instance(self, instance_data: dict) -&gt; None:\n        \"\"\"Add a publish instance to the current project.\n\n        Args:\n            instance_data (dict): Publish instance to add.\n\n        \"\"\"\n        data = self.get_ayon_data()\n        publish_instances = self.get_publish_instances()\n        publish_instances.append(instance_data)\n        data[MOCHA_INSTANCES_KEY] = publish_instances\n\n        self.update_ayon_data(data)\n\n    def update_publish_instance(\n            self,\n            instance_id: str,\n            data: dict,\n    ) -&gt; None:\n        \"\"\"Update a publish instance in the current project.\n\n        Args:\n            instance_id (str): Publish instance id to update.\n            data (dict): Data to update.\n\n        \"\"\"\n        ayon_data = self.get_ayon_data()\n        publish_instances = self.get_publish_instances()\n        for idx, publish_instance in enumerate(publish_instances):\n            if publish_instance[\"instance_id\"] == instance_id:\n                publish_instances[idx] = data\n                break\n        ayon_data[MOCHA_INSTANCES_KEY] = publish_instances\n\n        self.update_ayon_data(ayon_data)\n\n    def write_create_instances(\n            self, instances: list[dict]) -&gt; None:\n        \"\"\"Write publish instances to the current project.\"\"\"\n        ayon_data = self.get_ayon_data()\n        ayon_data[MOCHA_INSTANCES_KEY] = instances\n        self.update_ayon_data(ayon_data)\n\n    def remove_create_instance(self, instance_id: str) -&gt; None:\n        \"\"\"Remove a publishing instance from the current project.\n\n        Args:\n            instance_id (str): Publish instance id to remove.\n\n        \"\"\"\n        data = self.get_ayon_data()\n        publish_instances = self.get_publish_instances()\n        publish_instances = [\n            publish_instance\n            for publish_instance in publish_instances\n            if publish_instance[\"instance_id\"] != instance_id\n        ]\n        data[MOCHA_INSTANCES_KEY] = publish_instances\n\n        self.update_ayon_data(data)\n\n    def get_current_project(self) -&gt; Project:\n        \"\"\"Return the current project.\"\"\"\n        project = _get_current_project()\n        if not project:\n            if not self._uninitialized_project_warning_shown:\n                show_message_dialog(\n                    \"No project is opened.\",\n                    (\n                        \"Please open or save a project first, otherwise \"\n                        \"you won't be able to see the results of any \"\n                        \"operations you'll make.\"\n                    ),\n                    parent=get_main_window(),\n                )\n                self._uninitialized_project_warning_shown = True\n            return create_empty_project()\n        return project\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/pipeline.html#client.ayon_mocha.api.pipeline.MochaProHost.add_container","title":"<code>add_container(container)</code>","text":"<p>Add a container to the current workfile.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>Container</code> <p>Container to add.</p> required Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def add_container(self, container: Container) -&gt; None:\n    \"\"\"Add a container to the current workfile.\n\n    Args:\n        container (Container): Container to add.\n\n    \"\"\"\n    data = self.get_ayon_data()\n    containers_dicts = list(self.get_containers())\n    containers = [\n        Container(**_container) for _container in containers_dicts\n    ]\n    to_remove = [\n        idx\n        for idx, _container in enumerate(containers)\n        if _container.name == container.name\n        and _container.namespace == container.namespace\n    ]\n    for idx in reversed(to_remove):\n        containers.pop(idx)\n\n    data[MOCHA_CONTAINERS_KEY] = [\n        *containers, dataclasses.asdict(container)]\n\n    self.update_ayon_data(data)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/pipeline.html#client.ayon_mocha.api.pipeline.MochaProHost.add_publish_instance","title":"<code>add_publish_instance(instance_data)</code>","text":"<p>Add a publish instance to the current project.</p> <p>Parameters:</p> Name Type Description Default <code>instance_data</code> <code>dict</code> <p>Publish instance to add.</p> required Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def add_publish_instance(self, instance_data: dict) -&gt; None:\n    \"\"\"Add a publish instance to the current project.\n\n    Args:\n        instance_data (dict): Publish instance to add.\n\n    \"\"\"\n    data = self.get_ayon_data()\n    publish_instances = self.get_publish_instances()\n    publish_instances.append(instance_data)\n    data[MOCHA_INSTANCES_KEY] = publish_instances\n\n    self.update_ayon_data(data)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/pipeline.html#client.ayon_mocha.api.pipeline.MochaProHost.get_ayon_data","title":"<code>get_ayon_data()</code>","text":"<p>Get AYON context data from the current project.</p> <p>Mocha Pro doesn't have any custom node or other place to store metadata, so we store context data in the project notes encoded as JSON and wrapped in a special guard string <code>AYON_CONTEXT::...::AYON_CONTEXT_END</code>.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Context data.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def get_ayon_data(self) -&gt; dict:\n    \"\"\"Get AYON context data from the current project.\n\n    Mocha Pro doesn't have any custom node or other\n    place to store metadata, so we store context data in\n    the project notes encoded as JSON and wrapped in a\n    special guard string `AYON_CONTEXT::...::AYON_CONTEXT_END`.\n\n    Returns:\n        dict: Context data.\n\n    \"\"\"\n    # sourcery skip: use-named-expression\n    project = self.get_current_project()\n    m = re.search(AYON_METADATA_REGEX, project.notes)\n    if not m:\n        self._create_ayon_data()\n        return {}\n    try:\n        context = json.loads(m[\"context\"]) if m else {}\n    except ValueError:\n        self.log.debug(\"AYON data is not valid json\")\n        # AYON data not found or invalid, create empty placeholder\n        self._create_ayon_data()\n        return {}\n\n    return context\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/pipeline.html#client.ayon_mocha.api.pipeline.MochaProHost.get_containers","title":"<code>get_containers()</code>","text":"<p>Get containers from the current workfile.</p> <p>Yields:</p> Name Type Description <code>Generator</code> <code>dict</code> <p>Container data.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def get_containers(self) -&gt; Generator[dict, None, list]:\n    \"\"\"Get containers from the current workfile.\n\n    Yields:\n        Generator: Container data.\n\n    \"\"\"\n    # sourcery skip: use-named-expression\n    data = self.get_ayon_data()\n    if data:\n        yield from data.get(MOCHA_CONTAINERS_KEY, [])\n    yield {}\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/pipeline.html#client.ayon_mocha.api.pipeline.MochaProHost.get_context_data","title":"<code>get_context_data()</code>","text":"<p>Get context data from the current project.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Context data.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def get_context_data(self) -&gt; dict:\n    \"\"\"Get context data from the current project.\n\n    Returns:\n        dict: Context data.\n\n    \"\"\"\n    data = self.get_ayon_data()\n\n    return data.get(MOCHA_CONTEXT_KEY, {})\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/pipeline.html#client.ayon_mocha.api.pipeline.MochaProHost.get_current_project","title":"<code>get_current_project()</code>","text":"<p>Return the current project.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def get_current_project(self) -&gt; Project:\n    \"\"\"Return the current project.\"\"\"\n    project = _get_current_project()\n    if not project:\n        if not self._uninitialized_project_warning_shown:\n            show_message_dialog(\n                \"No project is opened.\",\n                (\n                    \"Please open or save a project first, otherwise \"\n                    \"you won't be able to see the results of any \"\n                    \"operations you'll make.\"\n                ),\n                parent=get_main_window(),\n            )\n            self._uninitialized_project_warning_shown = True\n        return create_empty_project()\n    return project\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/pipeline.html#client.ayon_mocha.api.pipeline.MochaProHost.get_current_workfile","title":"<code>get_current_workfile()</code>","text":"<p>Get the current workfile.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The current workfile.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def get_current_workfile(self) -&gt; Optional[str]:  # noqa: PLR6301\n    \"\"\"Get the current workfile.\n\n    Returns:\n        Optional[str]: The current workfile.\n\n    \"\"\"\n    file_path = current_file()\n    return file_path.as_posix() if file_path else None\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/pipeline.html#client.ayon_mocha.api.pipeline.MochaProHost.get_publish_instances","title":"<code>get_publish_instances()</code>","text":"<p>Get publish instances from the current project.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: Publish instances.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def get_publish_instances(self) -&gt; list[dict]:\n    \"\"\"Get publish instances from the current project.\n\n    Returns:\n        list[dict]: Publish instances.\n\n    \"\"\"\n    data = self.get_ayon_data()\n    return data.get(MOCHA_INSTANCES_KEY, [])\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/pipeline.html#client.ayon_mocha.api.pipeline.MochaProHost.get_workfile_extensions","title":"<code>get_workfile_extensions()</code>","text":"<p>Get the workfile extensions.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Workfile extensions.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def get_workfile_extensions(self) -&gt; list[str]:  # noqa: PLR6301\n    \"\"\"Get the workfile extensions.\n\n    Returns:\n        list[str]: Workfile extensions.\n\n    \"\"\"\n    return file_extensions()\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/pipeline.html#client.ayon_mocha.api.pipeline.MochaProHost.install","title":"<code>install()</code>","text":"<p>Initialize the host.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def install(self) -&gt; None:\n    \"\"\"Initialize the host.\"\"\"\n    pyblish.api.register_host(self.name)\n    pyblish.api.register_plugin_path(PUBLISH_PATH.as_posix())\n    register_loader_plugin_path(LOAD_PATH.as_posix())\n    register_creator_plugin_path(CREATE_PATH.as_posix())\n\n    # QtCore.QTimer.singleShot(0, self._install_menu)\n    self._install_menu()\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/pipeline.html#client.ayon_mocha.api.pipeline.MochaProHost.open_workfile","title":"<code>open_workfile(filepath)</code>","text":"<p>Open the workfile.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def open_workfile(self, filepath: str) -&gt; None:  # noqa: PLR6301\n    \"\"\"Open the workfile.\"\"\"\n    open_file(Path(filepath))\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/pipeline.html#client.ayon_mocha.api.pipeline.MochaProHost.remove_container","title":"<code>remove_container(container)</code>","text":"<p>Remove a container from the current workfile.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>Container</code> <p>Container to remove.</p> required Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def remove_container(self, container: Container) -&gt; None:\n    \"\"\"Remove a container from the current workfile.\n\n    Args:\n        container (Container): Container to remove.\n\n    \"\"\"\n    data = self.get_ayon_data()\n    containers_dicts = list(self.get_containers())\n    containers = [\n        Container(**_container) for _container in containers_dicts\n    ]\n    to_remove = [\n        idx\n        for idx, _container in enumerate(containers)\n        if _container.name == container.name\n        and _container.namespace == container.namespace\n    ]\n    for idx in reversed(to_remove):\n        containers.pop(idx)\n\n    data[MOCHA_CONTAINERS_KEY] = [\n        dataclasses.asdict(_container) for _container in containers]\n\n    self.update_ayon_data(data)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/pipeline.html#client.ayon_mocha.api.pipeline.MochaProHost.remove_create_instance","title":"<code>remove_create_instance(instance_id)</code>","text":"<p>Remove a publishing instance from the current project.</p> <p>Parameters:</p> Name Type Description Default <code>instance_id</code> <code>str</code> <p>Publish instance id to remove.</p> required Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def remove_create_instance(self, instance_id: str) -&gt; None:\n    \"\"\"Remove a publishing instance from the current project.\n\n    Args:\n        instance_id (str): Publish instance id to remove.\n\n    \"\"\"\n    data = self.get_ayon_data()\n    publish_instances = self.get_publish_instances()\n    publish_instances = [\n        publish_instance\n        for publish_instance in publish_instances\n        if publish_instance[\"instance_id\"] != instance_id\n    ]\n    data[MOCHA_INSTANCES_KEY] = publish_instances\n\n    self.update_ayon_data(data)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/pipeline.html#client.ayon_mocha.api.pipeline.MochaProHost.save_workfile","title":"<code>save_workfile(dst_path=None)</code>","text":"<p>Save the workfile.</p> <p>Parameters:</p> Name Type Description Default <code>dst_path</code> <code>str</code> <p>The destination path to save the file to. Defaults to None.</p> <code>None</code> <p>Todo (antirotor): This needs to display error if the project     isn't initialized yet.     https://github.com/ynput/ayon-core/issues/1075</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def save_workfile(self, dst_path: Optional[str] = None) -&gt; None:  # noqa: PLR6301\n    \"\"\"Save the workfile.\n\n    Args:\n        dst_path (str, optional): The destination path to save the file to.\n            Defaults to None.\n\n    Todo (antirotor): This needs to display error if the project\n        isn't initialized yet.\n        https://github.com/ynput/ayon-core/issues/1075\n\n    \"\"\"\n    if dst_path:\n        save_file(Path(dst_path))\n    else:\n        save_file(filepath=None)\n    if not _get_current_project():\n        reset_frame_range(_get_current_project())\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/pipeline.html#client.ayon_mocha.api.pipeline.MochaProHost.update_ayon_data","title":"<code>update_ayon_data(data)</code>","text":"<p>Update AYON context data in the current project.</p> <p>Serialize context data as json and store it in the project notes. If the context data is not found, create a placeholder there. See <code>get_context_data</code> for more info.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Context data.</p> required Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def update_ayon_data(self, data: dict) -&gt; None:\n    \"\"\"Update AYON context data in the current project.\n\n    Serialize context data as json and store it in the\n    project notes. If the context data is not found, create\n    a placeholder there. See `get_context_data` for more info.\n\n    Args:\n        data (dict): Context data.\n\n    \"\"\"\n    project = self.get_current_project()\n    original_data = self.get_ayon_data()\n\n    updated_data = original_data.copy()\n    updated_data.update(data)\n    update_str = json.dumps(\n        updated_data or {}, indent=4, cls=AYONJSONEncoder)\n\n    project.notes = re.sub(\n            AYON_METADATA_REGEX,\n            AYON_METADATA_GUARD.format(update_str),\n            project.notes,\n        )\n    update_ui()\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/pipeline.html#client.ayon_mocha.api.pipeline.MochaProHost.update_context_data","title":"<code>update_context_data(data, changes)</code>","text":"<p>Update context data in the current project.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Context data.</p> required <code>changes</code> <code>dict</code> <p>Changes to the context data.</p> required Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def update_context_data(\n        self, data: dict, changes: dict) -&gt; None:\n    \"\"\"Update context data in the current project.\n\n    Args:\n        data (dict): Context data.\n        changes (dict): Changes to the context data.\n\n    \"\"\"\n    if not data:\n        return\n    ayon_data = self.get_ayon_data()\n    ayon_data[MOCHA_CONTEXT_KEY] = data\n    self.update_ayon_data(ayon_data)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/pipeline.html#client.ayon_mocha.api.pipeline.MochaProHost.update_publish_instance","title":"<code>update_publish_instance(instance_id, data)</code>","text":"<p>Update a publish instance in the current project.</p> <p>Parameters:</p> Name Type Description Default <code>instance_id</code> <code>str</code> <p>Publish instance id to update.</p> required <code>data</code> <code>dict</code> <p>Data to update.</p> required Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def update_publish_instance(\n        self,\n        instance_id: str,\n        data: dict,\n) -&gt; None:\n    \"\"\"Update a publish instance in the current project.\n\n    Args:\n        instance_id (str): Publish instance id to update.\n        data (dict): Data to update.\n\n    \"\"\"\n    ayon_data = self.get_ayon_data()\n    publish_instances = self.get_publish_instances()\n    for idx, publish_instance in enumerate(publish_instances):\n        if publish_instance[\"instance_id\"] == instance_id:\n            publish_instances[idx] = data\n            break\n    ayon_data[MOCHA_INSTANCES_KEY] = publish_instances\n\n    self.update_ayon_data(ayon_data)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/pipeline.html#client.ayon_mocha.api.pipeline.MochaProHost.write_create_instances","title":"<code>write_create_instances(instances)</code>","text":"<p>Write publish instances to the current project.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def write_create_instances(\n        self, instances: list[dict]) -&gt; None:\n    \"\"\"Write publish instances to the current project.\"\"\"\n    ayon_data = self.get_ayon_data()\n    ayon_data[MOCHA_INSTANCES_KEY] = instances\n    self.update_ayon_data(ayon_data)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/pipeline.html#client.ayon_mocha.api.pipeline.reset_frame_range","title":"<code>reset_frame_range(project)</code>","text":"<p>Reset frame range to the current task entity.</p> Source code in <code>client/ayon_mocha/api/pipeline.py</code> <pre><code>def reset_frame_range(project: Optional[Project]) -&gt; None:\n    \"\"\"Reset frame range to the current task entity.\"\"\"\n    task_entity = get_current_task_entity()\n    frame_start = task_entity[\"attrib\"][\"frameStart\"]\n    frame_end = task_entity[\"attrib\"][\"frameEnd\"]\n    fps = task_entity[\"attrib\"][\"fps\"]\n    # resolution_width = task_entity[\"attrib\"][\"resolutionWidth\"]\n    # resolution_height = task_entity[\"attrib\"][\"resolutionHeight\"]\n    # pixel_aspect = task_entity[\"attrib\"][\"pixelAspect\"]\n\n    if not project:\n        host: MochaProHost = registered_host()\n        project = host.get_current_project()\n\n    project.length = int(frame_end) - int(frame_start) + 1\n    project.first_frame_offset = int(frame_start)\n    project.frame_rate = fps\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/plugin.html","title":"plugin","text":"<p>Plugin API for Mocha Pro AYON addon.</p>"},{"location":"autoapi/client/ayon_mocha/api/plugin.html#client.ayon_mocha.api.plugin.MochaCreator","title":"<code>MochaCreator</code>","text":"<p>               Bases: <code>Creator</code></p> <p>Mocha Pro creator.</p> Source code in <code>client/ayon_mocha/api/plugin.py</code> <pre><code>class MochaCreator(Creator):\n    \"\"\"Mocha Pro creator.\"\"\"\n    def create(self,\n               product_name: str,\n               instance_data: dict,\n               pre_create_data: dict) -&gt; CreatedInstance:\n        \"\"\"Create product instance in the host application.\n\n        Args:\n            product_name (str): Name of the product to be created.\n            instance_data (dict): Data to be used for creating the product.\n            pre_create_data (dict): Data to be used before\n                creating the product.\n\n        Returns:\n            CreatedInstance: Created product instance.\n\n        \"\"\"\n        instance = CreatedInstance(\n            self.product_type,\n            product_name,\n            instance_data,\n            self,\n        )\n        self._add_instance_to_context(instance)\n        host: MochaProHost = self.host\n        host.add_publish_instance(instance.data_to_store())\\\n\n        return instance\n\n    def collect_instances(self) -&gt; None:\n        \"\"\"Collect instances from the host application.\"\"\"\n        host: MochaProHost = self.host\n        for instance_data in host.get_publish_instances():\n            if instance_data[\"creator_identifier\"] != self.identifier:\n                continue\n            created_instance = CreatedInstance.from_existing(\n                instance_data, self\n            )\n            self._add_instance_to_context(created_instance)\n\n    def update_instances(self, update_list: list[dict]) -&gt; None:\n        \"\"\"Update instances in the host application.\n\n        Args:\n            update_list (list[dict]): List of instances to be updated.\n\n        \"\"\"\n        host: MochaProHost = self.host\n        concurrent_instances = host.get_publish_instances()\n        instances_by_id = {\n            i_data[\"instance_id\"]: i_data\n            for i_data in concurrent_instances\n            if i_data[\"instance_id\"]\n        }\n\n        instance: CreatedInstance\n        for instance, _changes in update_list:\n            cur_instance_data = instances_by_id.get(\n                instance.data[\"instance_id\"])\n            new_data = instance.data_to_store()\n            if cur_instance_data is None:\n                concurrent_instances.append(instance.data_to_store())\n                continue\n            for key in set(cur_instance_data) - set(new_data):\n                cur_instance_data.pop(key)\n            cur_instance_data.update(new_data)\n        host.write_create_instances(concurrent_instances)\n\n    def remove_instances(self, instances: list[CreatedInstance]) -&gt; None:\n        \"\"\"Remove instances from the host application.\n\n        Args:\n            instances (list[CreatedInstance]): List of instances to be removed.\n\n        \"\"\"\n        host: MochaProHost = self.host\n        for instance in instances:\n            self._remove_instance_from_context(instance)\n            host.remove_create_instance(instance.id)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/plugin.html#client.ayon_mocha.api.plugin.MochaCreator.collect_instances","title":"<code>collect_instances()</code>","text":"<p>Collect instances from the host application.</p> Source code in <code>client/ayon_mocha/api/plugin.py</code> <pre><code>def collect_instances(self) -&gt; None:\n    \"\"\"Collect instances from the host application.\"\"\"\n    host: MochaProHost = self.host\n    for instance_data in host.get_publish_instances():\n        if instance_data[\"creator_identifier\"] != self.identifier:\n            continue\n        created_instance = CreatedInstance.from_existing(\n            instance_data, self\n        )\n        self._add_instance_to_context(created_instance)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/plugin.html#client.ayon_mocha.api.plugin.MochaCreator.create","title":"<code>create(product_name, instance_data, pre_create_data)</code>","text":"<p>Create product instance in the host application.</p> <p>Parameters:</p> Name Type Description Default <code>product_name</code> <code>str</code> <p>Name of the product to be created.</p> required <code>instance_data</code> <code>dict</code> <p>Data to be used for creating the product.</p> required <code>pre_create_data</code> <code>dict</code> <p>Data to be used before creating the product.</p> required <p>Returns:</p> Name Type Description <code>CreatedInstance</code> <code>CreatedInstance</code> <p>Created product instance.</p> Source code in <code>client/ayon_mocha/api/plugin.py</code> <pre><code>def create(self,\n           product_name: str,\n           instance_data: dict,\n           pre_create_data: dict) -&gt; CreatedInstance:\n    \"\"\"Create product instance in the host application.\n\n    Args:\n        product_name (str): Name of the product to be created.\n        instance_data (dict): Data to be used for creating the product.\n        pre_create_data (dict): Data to be used before\n            creating the product.\n\n    Returns:\n        CreatedInstance: Created product instance.\n\n    \"\"\"\n    instance = CreatedInstance(\n        self.product_type,\n        product_name,\n        instance_data,\n        self,\n    )\n    self._add_instance_to_context(instance)\n    host: MochaProHost = self.host\n    host.add_publish_instance(instance.data_to_store())\\\n\n    return instance\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/plugin.html#client.ayon_mocha.api.plugin.MochaCreator.remove_instances","title":"<code>remove_instances(instances)</code>","text":"<p>Remove instances from the host application.</p> <p>Parameters:</p> Name Type Description Default <code>instances</code> <code>list[CreatedInstance]</code> <p>List of instances to be removed.</p> required Source code in <code>client/ayon_mocha/api/plugin.py</code> <pre><code>def remove_instances(self, instances: list[CreatedInstance]) -&gt; None:\n    \"\"\"Remove instances from the host application.\n\n    Args:\n        instances (list[CreatedInstance]): List of instances to be removed.\n\n    \"\"\"\n    host: MochaProHost = self.host\n    for instance in instances:\n        self._remove_instance_from_context(instance)\n        host.remove_create_instance(instance.id)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/plugin.html#client.ayon_mocha.api.plugin.MochaCreator.update_instances","title":"<code>update_instances(update_list)</code>","text":"<p>Update instances in the host application.</p> <p>Parameters:</p> Name Type Description Default <code>update_list</code> <code>list[dict]</code> <p>List of instances to be updated.</p> required Source code in <code>client/ayon_mocha/api/plugin.py</code> <pre><code>def update_instances(self, update_list: list[dict]) -&gt; None:\n    \"\"\"Update instances in the host application.\n\n    Args:\n        update_list (list[dict]): List of instances to be updated.\n\n    \"\"\"\n    host: MochaProHost = self.host\n    concurrent_instances = host.get_publish_instances()\n    instances_by_id = {\n        i_data[\"instance_id\"]: i_data\n        for i_data in concurrent_instances\n        if i_data[\"instance_id\"]\n    }\n\n    instance: CreatedInstance\n    for instance, _changes in update_list:\n        cur_instance_data = instances_by_id.get(\n            instance.data[\"instance_id\"])\n        new_data = instance.data_to_store()\n        if cur_instance_data is None:\n            concurrent_instances.append(instance.data_to_store())\n            continue\n        for key in set(cur_instance_data) - set(new_data):\n            cur_instance_data.pop(key)\n        cur_instance_data.update(new_data)\n    host.write_create_instances(concurrent_instances)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/plugin.html#client.ayon_mocha.api.plugin.MochaLoader","title":"<code>MochaLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Mocha Pro loader base class.</p> Source code in <code>client/ayon_mocha/api/plugin.py</code> <pre><code>class MochaLoader(load.LoaderPlugin):\n    \"\"\"Mocha Pro loader base class.\"\"\"\n    settings_category = \"mochapro\"\n    hosts: ClassVar[list[str]] = [\"mochapro\"]\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/workio.html","title":"workio","text":"<p>Host API for working with workfiles.</p>"},{"location":"autoapi/client/ayon_mocha/api/workio.html#client.ayon_mocha.api.workio.current_file","title":"<code>current_file()</code>","text":"<p>Return the current workfile.</p> Source code in <code>client/ayon_mocha/api/workio.py</code> <pre><code>def current_file() -&gt; Optional[Path]:\n    \"\"\"Return the current workfile.\"\"\"\n    project = get_current_project()\n    if not project:\n        return None\n    return Path(project.project_file)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/workio.html#client.ayon_mocha.api.workio.file_extensions","title":"<code>file_extensions()</code>","text":"<p>Return file extensions for workfiles.</p> Source code in <code>client/ayon_mocha/api/workio.py</code> <pre><code>def file_extensions() -&gt; list[str]:\n    \"\"\"Return file extensions for workfiles.\"\"\"\n    return [\".mocha\"]\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/workio.html#client.ayon_mocha.api.workio.has_unsave_changes","title":"<code>has_unsave_changes()</code>","text":"<p>Return True if the current workfile has unsaved changes.</p> <p>Mocha Pro doesn't have API to query this state so we always return False.</p> Source code in <code>client/ayon_mocha/api/workio.py</code> <pre><code>def has_unsave_changes() -&gt; bool:\n    \"\"\"Return True if the current workfile has unsaved changes.\n\n    Mocha Pro doesn't have API to query this state so we always return False.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/workio.html#client.ayon_mocha.api.workio.open_file","title":"<code>open_file(filepath)</code>","text":"<p>Open a workfile.</p> <p>There is probably no way to open a workfile in Mocha Pro directly, so we run Mocha Pro with the footage file as an argument, this will open new Mocha Pro window with the project loaded, and we kill the original application.There wasn't even a way to quit Mocha Pro in standard way, so we terminate it rather forcefully.</p> <p>Todo (antirotor): quit mocha only if the run_mocha was successful.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Path</code> <p>Path to the workfile.</p> required Source code in <code>client/ayon_mocha/api/workio.py</code> <pre><code>def open_file(filepath: Path) -&gt; None:\n    \"\"\"Open a workfile.\n\n    There is probably no way to open a workfile in Mocha Pro directly,\n    so we run Mocha Pro with the footage file as an argument, this will\n    open new Mocha Pro window with the project loaded, and we kill the\n    original application.There wasn't even a way to quit Mocha Pro\n    in standard way, so we terminate it rather forcefully.\n\n    Todo (antirotor): quit mocha only if the run_mocha was successful.\n\n    Args:\n        filepath (Path): Path to the workfile.\n\n    \"\"\"\n    run_mocha(footage_path=filepath.as_posix())\n    quit_mocha()\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/api/workio.html#client.ayon_mocha.api.workio.save_file","title":"<code>save_file(filepath)</code>","text":"<p>Save the current workfile.</p> <p>Note that project cannot be saved without being created first. To create the project, you need to specify clip first, thus we can't create workfile from the un-initialized project within Mocha Pro.</p> Source code in <code>client/ayon_mocha/api/workio.py</code> <pre><code>def save_file(filepath: Optional[Path]) -&gt; None:\n    \"\"\"Save the current workfile.\n\n    Note that project cannot be saved without being created first.\n    To create the project, you need to specify clip first, thus\n    we can't create workfile from the un-initialized project within Mocha Pro.\n\n    \"\"\"\n    project = get_current_project()\n    if not project:\n        if not filepath:\n            return\n        project = create_empty_project(filepath)\n    if filepath:\n        project.save_as(filepath.as_posix())\n        # now we need to reopen mocha with the new project\n        open_file(filepath)\n        return\n    project.save()\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_mocha/plugins/create/index.html","title":"create","text":""},{"location":"autoapi/client/ayon_mocha/plugins/create/create_shape_data.html","title":"create_shape_data","text":"<p>Create shape data instance.</p>"},{"location":"autoapi/client/ayon_mocha/plugins/create/create_shape_data.html#client.ayon_mocha.plugins.create.create_shape_data.CreateShapeData","title":"<code>CreateShapeData</code>","text":"<p>               Bases: <code>MochaCreator</code></p> <p>Create shape instance.</p> Source code in <code>client/ayon_mocha/plugins/create/create_shape_data.py</code> <pre><code>class CreateShapeData(MochaCreator):\n    \"\"\"Create shape instance.\"\"\"\n    identifier = \"io.ayon.creators.mochapro.matteshapes\"\n    label = \"Shape Data\"\n    description = __doc__\n    product_type = \"matteshapes\"\n    icon = \"circle\"\n\n    def get_attr_defs_for_instance(\n            self, instance: CreatedInstance) -&gt; list:\n        \"\"\"Get attribute definitions for instance.\n\n        Returns:\n            list: List of attribute definitions.\n\n        \"\"\"\n        exporter_items = {ex.id: ex.label for ex in get_shape_exporters()}\n\n        version = get_mocha_version()\n        settings = (\n            self.project_settings\n            [\"mocha\"][\"create\"][\"CreateShapeData\"]\n        )\n\n        try:\n            exporter_settings = (\n                settings\n                [f\"mocha_{version}\"]\n                [\"default_exporters\"]\n            )\n        except KeyError:\n            exporter_settings = (\n                settings\n                [\"mocha_2024_5\"]\n                [\"default_exporters\"]\n            )\n\n        exporters = get_shape_exporters()\n        exporter_items = {ex.id: ex.label for ex in exporters}\n\n        preselect_exporters = [\n            ex.id\n            for ex in exporters\n            if ex.short_name in exporter_settings\n        ]\n\n        layers = {\n                    idx: layer.name\n                    for idx, layer in enumerate(\n                        self.create_context.host.get_current_project().layers)\n                } or {-1: \"No layers\"}\n\n        return [\n            EnumDef(\"layers\",\n                    label=\"Layers\",\n                    items=layers,\n                    multiselection=True),\n            EnumDef(\"exporter\",\n                    label=\"Exporter format\",\n                    items=exporter_items,\n                    multiselection=True,\n                    default=preselect_exporters),\n            UISeparatorDef(),\n            UILabelDef(\n                \"Exporter Options (not all are available in all exporters)\"),\n            EnumDef(\"layer_mode\", label=\"Layer mode\",\n                    items={\n                        \"selected\": \"Selected layers\",\n                        \"all\": \"All layers\"\n                    }),\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/create/create_shape_data.html#client.ayon_mocha.plugins.create.create_shape_data.CreateShapeData.get_attr_defs_for_instance","title":"<code>get_attr_defs_for_instance(instance)</code>","text":"<p>Get attribute definitions for instance.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>List of attribute definitions.</p> Source code in <code>client/ayon_mocha/plugins/create/create_shape_data.py</code> <pre><code>def get_attr_defs_for_instance(\n        self, instance: CreatedInstance) -&gt; list:\n    \"\"\"Get attribute definitions for instance.\n\n    Returns:\n        list: List of attribute definitions.\n\n    \"\"\"\n    exporter_items = {ex.id: ex.label for ex in get_shape_exporters()}\n\n    version = get_mocha_version()\n    settings = (\n        self.project_settings\n        [\"mocha\"][\"create\"][\"CreateShapeData\"]\n    )\n\n    try:\n        exporter_settings = (\n            settings\n            [f\"mocha_{version}\"]\n            [\"default_exporters\"]\n        )\n    except KeyError:\n        exporter_settings = (\n            settings\n            [\"mocha_2024_5\"]\n            [\"default_exporters\"]\n        )\n\n    exporters = get_shape_exporters()\n    exporter_items = {ex.id: ex.label for ex in exporters}\n\n    preselect_exporters = [\n        ex.id\n        for ex in exporters\n        if ex.short_name in exporter_settings\n    ]\n\n    layers = {\n                idx: layer.name\n                for idx, layer in enumerate(\n                    self.create_context.host.get_current_project().layers)\n            } or {-1: \"No layers\"}\n\n    return [\n        EnumDef(\"layers\",\n                label=\"Layers\",\n                items=layers,\n                multiselection=True),\n        EnumDef(\"exporter\",\n                label=\"Exporter format\",\n                items=exporter_items,\n                multiselection=True,\n                default=preselect_exporters),\n        UISeparatorDef(),\n        UILabelDef(\n            \"Exporter Options (not all are available in all exporters)\"),\n        EnumDef(\"layer_mode\", label=\"Layer mode\",\n                items={\n                    \"selected\": \"Selected layers\",\n                    \"all\": \"All layers\"\n                }),\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/create/create_tracking_points.html","title":"create_tracking_points","text":"<p>Create tracking data instance.</p>"},{"location":"autoapi/client/ayon_mocha/plugins/create/create_tracking_points.html#client.ayon_mocha.plugins.create.create_tracking_points.CreateTrackingPoints","title":"<code>CreateTrackingPoints</code>","text":"<p>               Bases: <code>MochaCreator</code></p> <p>Create tracking points instance.</p> Source code in <code>client/ayon_mocha/plugins/create/create_tracking_points.py</code> <pre><code>class CreateTrackingPoints(MochaCreator):\n    \"\"\"Create tracking points instance.\"\"\"\n    identifier = \"io.ayon.creators.mochapro.trackpoints\"\n    label = \"Track Points\"\n    description = __doc__\n    product_type = \"trackpoints\"\n    icon = \"cubes\"\n\n    def get_attr_defs_for_instance(self, instance: CreatedInstance) -&gt; list:\n        \"\"\"Get attribute definitions for instance.\n\n        Returns:\n            list: List of attribute definitions.\n\n        \"\"\"\n        version = get_mocha_version()\n        settings = (\n            self.project_settings\n                [\"mocha\"][\"create\"][\"CreateTrackingPoints\"]\n        )\n\n        try:\n            exporter_settings = (\n                settings\n                [f\"mocha_{version}\"]\n                [\"default_exporters\"]\n            )\n        except KeyError:\n            exporter_settings = (\n                settings\n                [\"mocha_2024_5\"]\n                [\"default_exporters\"]\n            )\n\n        exporters = get_tracking_exporters()\n        exporter_items = {ex.id: ex.label for ex in exporters}\n\n        preselect_exporters = [\n            ex.id\n            for ex in exporters\n            if ex.short_name in exporter_settings\n        ]\n\n        layers = {\n                    idx: layer.name\n                    for idx, layer in enumerate(\n                        self.create_context.host.get_current_project().layers)\n                } or {-1: \"No layers\"}\n\n        return [\n            EnumDef(\"layers\",\n                    label=\"Layers\",\n                    items=layers,\n                    multiselection=True),\n            EnumDef(\"exporter\",\n                    label=\"Exporter format\",\n                    items=exporter_items,\n                    multiselection=True,\n                    default=preselect_exporters),\n            UISeparatorDef(),\n            UILabelDef(\n                \"Exporter Options (not all are available in all exporters)\"),\n            NumberDef(\n                \"frame_time\", label=\"Frame time\",\n                default=0.0),\n            BoolDef(\"invert\", label=\"Invert\", default=False),\n            BoolDef(\"remove_lens_distortion\",\n                    label=\"Remove lens distortion\", default=False),\n            EnumDef(\"layer_mode\", label=\"Layer mode\",\n                    items={\n                        \"selected\": \"Selected layers\",\n                        \"all\": \"All layers\"\n                    }),\n\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/create/create_tracking_points.html#client.ayon_mocha.plugins.create.create_tracking_points.CreateTrackingPoints.get_attr_defs_for_instance","title":"<code>get_attr_defs_for_instance(instance)</code>","text":"<p>Get attribute definitions for instance.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>List of attribute definitions.</p> Source code in <code>client/ayon_mocha/plugins/create/create_tracking_points.py</code> <pre><code>def get_attr_defs_for_instance(self, instance: CreatedInstance) -&gt; list:\n    \"\"\"Get attribute definitions for instance.\n\n    Returns:\n        list: List of attribute definitions.\n\n    \"\"\"\n    version = get_mocha_version()\n    settings = (\n        self.project_settings\n            [\"mocha\"][\"create\"][\"CreateTrackingPoints\"]\n    )\n\n    try:\n        exporter_settings = (\n            settings\n            [f\"mocha_{version}\"]\n            [\"default_exporters\"]\n        )\n    except KeyError:\n        exporter_settings = (\n            settings\n            [\"mocha_2024_5\"]\n            [\"default_exporters\"]\n        )\n\n    exporters = get_tracking_exporters()\n    exporter_items = {ex.id: ex.label for ex in exporters}\n\n    preselect_exporters = [\n        ex.id\n        for ex in exporters\n        if ex.short_name in exporter_settings\n    ]\n\n    layers = {\n                idx: layer.name\n                for idx, layer in enumerate(\n                    self.create_context.host.get_current_project().layers)\n            } or {-1: \"No layers\"}\n\n    return [\n        EnumDef(\"layers\",\n                label=\"Layers\",\n                items=layers,\n                multiselection=True),\n        EnumDef(\"exporter\",\n                label=\"Exporter format\",\n                items=exporter_items,\n                multiselection=True,\n                default=preselect_exporters),\n        UISeparatorDef(),\n        UILabelDef(\n            \"Exporter Options (not all are available in all exporters)\"),\n        NumberDef(\n            \"frame_time\", label=\"Frame time\",\n            default=0.0),\n        BoolDef(\"invert\", label=\"Invert\", default=False),\n        BoolDef(\"remove_lens_distortion\",\n                label=\"Remove lens distortion\", default=False),\n        EnumDef(\"layer_mode\", label=\"Layer mode\",\n                items={\n                    \"selected\": \"Selected layers\",\n                    \"all\": \"All layers\"\n                }),\n\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/create/create_workfile.html","title":"create_workfile","text":"<p>Creator plugin for creating workfiles.</p>"},{"location":"autoapi/client/ayon_mocha/plugins/create/create_workfile.html#client.ayon_mocha.plugins.create.create_workfile.CreateWorkfile","title":"<code>CreateWorkfile</code>","text":"<p>               Bases: <code>MochaCreator</code>, <code>AutoCreator</code></p> <p>Workfile auto-creator.</p> Source code in <code>client/ayon_mocha/plugins/create/create_workfile.py</code> <pre><code>class CreateWorkfile(MochaCreator, AutoCreator):\n    \"\"\"Workfile auto-creator.\"\"\"\n    identifier = \"io.ayon.creators.mochapro.workfiles\"\n    label = \"Workfile\"\n    product_type = \"workfile\"\n    icon = \"fa5.file\"\n\n    default_variant = \"Main\"\n\n    def create(self) -&gt; CreatedInstance:\n        \"\"\"Create workfile instance.\n\n        Returns:\n            CreatedInstance: Created workfile instance.\n\n        \"\"\"\n        variant = self.default_variant\n        current_instance = next(\n            (\n                instance for instance in self.create_context.instances\n                if instance.creator_identifier == self.identifier\n            ), None)\n\n        project_entity = self.create_context.get_current_project_entity()\n        project_name = project_entity[\"name\"]\n        folder_entity = self.create_context.get_current_folder_entity()\n        folder_path = folder_entity[\"path\"]\n        task_entity = self.create_context.get_current_task_entity()\n        task_name = task_entity[\"name\"]\n        host_name = self.create_context.host_name\n\n        current_folder_path = None\n        if current_instance is not None:\n            current_folder_path = current_instance[\"folderPath\"]\n\n        if current_instance is None:\n            folder_entity = ayon_api.get_folder_by_path(\n                project_name, folder_path\n            )\n            task_entity = ayon_api.get_task_by_name(\n                project_name, folder_entity[\"id\"], task_name\n            )\n            product_name = self.get_product_name(\n                project_name,\n                folder_entity,\n                task_entity,\n                variant,\n                host_name,\n            )\n            data = {\n                \"folderPath\": folder_path,\n                \"task\": task_name,\n                \"variant\": variant\n            }\n            data.update(\n                self.get_dynamic_data(\n                    project_name,\n                    folder_entity,\n                    task_entity,\n                    variant,\n                    host_name,\n                    current_instance)\n            )\n            self.log.info(\"Auto-creating workfile instance...\")\n            current_instance = CreatedInstance(\n                self.product_type, product_name, data, self\n            )\n            self._add_instance_to_context(current_instance)\n        elif (\n            current_folder_path != folder_path\n            or current_instance[\"task\"] != task_name\n        ):\n            # Update instance context if is not the same\n            folder_entity = ayon_api.get_folder_by_path(\n                project_name, folder_path\n            )\n            task_entity = ayon_api.get_task_by_name(\n                project_name, folder_entity[\"id\"], task_name\n            )\n            product_name = self.get_product_name(\n                project_name,\n                folder_entity,\n                task_entity,\n                variant,\n                host_name,\n            )\n\n            current_instance[\"folderPath\"] = folder_entity[\"path\"]\n            current_instance[\"task\"] = task_name\n            current_instance[\"productName\"] = product_name\n\n        return current_instance\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/create/create_workfile.html#client.ayon_mocha.plugins.create.create_workfile.CreateWorkfile.create","title":"<code>create()</code>","text":"<p>Create workfile instance.</p> <p>Returns:</p> Name Type Description <code>CreatedInstance</code> <code>CreatedInstance</code> <p>Created workfile instance.</p> Source code in <code>client/ayon_mocha/plugins/create/create_workfile.py</code> <pre><code>def create(self) -&gt; CreatedInstance:\n    \"\"\"Create workfile instance.\n\n    Returns:\n        CreatedInstance: Created workfile instance.\n\n    \"\"\"\n    variant = self.default_variant\n    current_instance = next(\n        (\n            instance for instance in self.create_context.instances\n            if instance.creator_identifier == self.identifier\n        ), None)\n\n    project_entity = self.create_context.get_current_project_entity()\n    project_name = project_entity[\"name\"]\n    folder_entity = self.create_context.get_current_folder_entity()\n    folder_path = folder_entity[\"path\"]\n    task_entity = self.create_context.get_current_task_entity()\n    task_name = task_entity[\"name\"]\n    host_name = self.create_context.host_name\n\n    current_folder_path = None\n    if current_instance is not None:\n        current_folder_path = current_instance[\"folderPath\"]\n\n    if current_instance is None:\n        folder_entity = ayon_api.get_folder_by_path(\n            project_name, folder_path\n        )\n        task_entity = ayon_api.get_task_by_name(\n            project_name, folder_entity[\"id\"], task_name\n        )\n        product_name = self.get_product_name(\n            project_name,\n            folder_entity,\n            task_entity,\n            variant,\n            host_name,\n        )\n        data = {\n            \"folderPath\": folder_path,\n            \"task\": task_name,\n            \"variant\": variant\n        }\n        data.update(\n            self.get_dynamic_data(\n                project_name,\n                folder_entity,\n                task_entity,\n                variant,\n                host_name,\n                current_instance)\n        )\n        self.log.info(\"Auto-creating workfile instance...\")\n        current_instance = CreatedInstance(\n            self.product_type, product_name, data, self\n        )\n        self._add_instance_to_context(current_instance)\n    elif (\n        current_folder_path != folder_path\n        or current_instance[\"task\"] != task_name\n    ):\n        # Update instance context if is not the same\n        folder_entity = ayon_api.get_folder_by_path(\n            project_name, folder_path\n        )\n        task_entity = ayon_api.get_task_by_name(\n            project_name, folder_entity[\"id\"], task_name\n        )\n        product_name = self.get_product_name(\n            project_name,\n            folder_entity,\n            task_entity,\n            variant,\n            host_name,\n        )\n\n        current_instance[\"folderPath\"] = folder_entity[\"path\"]\n        current_instance[\"task\"] = task_name\n        current_instance[\"productName\"] = product_name\n\n    return current_instance\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/load/index.html","title":"load","text":""},{"location":"autoapi/client/ayon_mocha/plugins/load/load_clip.html","title":"load_clip","text":"<p>Load a clip from a file.</p>"},{"location":"autoapi/client/ayon_mocha/plugins/load/load_clip.html#client.ayon_mocha.plugins.load.load_clip.LoadClip","title":"<code>LoadClip</code>","text":"<p>               Bases: <code>MochaLoader</code></p> <p>Load a clip from a file.</p> Source code in <code>client/ayon_mocha/plugins/load/load_clip.py</code> <pre><code>class LoadClip(MochaLoader):\n    \"\"\"Load a clip from a file.\"\"\"\n\n    label = \"Load Clip\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    product_types: ClassVar[set[str]] = {\"*\"}\n    representations: ClassVar[set[str]] = {\"*\"}\n    extensions: ClassVar[set[str]] = {\n        ext.lstrip(\".\") for ext in IMAGE_EXTENSIONS}\n\n    def load(self,\n             context: dict,\n             name: Optional[str] = None,\n             namespace: Optional[str] = None,\n             options: Optional[dict] = None) -&gt; None:\n        \"\"\"Load a clip from a file.\"\"\"\n        host: MochaProHost = registered_host()\n        project = host.get_current_project()\n        with project.undo_group():\n            file_path = self.filepath_from_context(context)\n\n            # Check if the clip with the same name already exists\n            # Mocha will load clips with the same name, but it will\n            # show in the UI just one of them, and it makes things\n            # confusing for the user.\n            clips = project.get_clips()\n            if name in clips:\n                self.log.warning(\"Clip %s already exists\", name)\n                idx = 1\n                while f\"{name}_{idx}\" in clips:\n                    idx += 1\n                name = f\"{name}_{idx}\"\n\n            clip = Clip(file_path, name)\n            project.add_clip(clip, name)\n            project.new_output_clip(clip, name)\n\n            container = Container(\n                name=name,\n                namespace=namespace or \"\",\n                loader=self.__class__.__name__,\n                representation=str(context[\"representation\"][\"id\"]),\n                objectName=clip.name,\n                timestamp=time.time_ns()\n            )\n            host.add_container(container)\n            update_ui()\n            self.log.debug(\"Loaded clip: %s\", clip)\n\n    def switch(self, container: dict, context: dict) -&gt; None:\n        \"\"\"Switch the image sequence on the current camera.\"\"\"\n        self.update(container, context)\n\n    def remove(self, container: dict) -&gt; None:\n        \"\"\"Remove a container.\"\"\"\n        host: MochaProHost = registered_host()\n        project = host.get_current_project()\n\n        clips = project.get_clips()\n        clip = clips.get(container[\"objectName\"])\n        if not clip:\n            self.log.warning(\"Clip %s not found\", container[\"objectName\"])\n            return\n        del clip\n        host.remove_container(Container(**container))\n\n    def update(self, container: dict, context: dict) -&gt; None:\n        \"\"\"Update a container.\"\"\"\n        host: MochaProHost = registered_host()\n\n        version_entity = context[\"version\"]\n        repre_entity = context[\"representation\"]\n\n        file_path = get_representation_path(repre_entity)\n        project = host.get_current_project()\n        clips = project.get_clips()\n        try:\n            clips[container[\"objectName\"]].relink(file_path)\n        except KeyError:\n            self.log.warning(\"Clip %s not found\", container[\"objectName\"])\n        update_ui()\n\n        container[\"representation\"] = repre_entity[\"id\"]\n        container[\"version\"] = str(version_entity[\"version\"])\n        host.add_container(Container(**container))\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/load/load_clip.html#client.ayon_mocha.plugins.load.load_clip.LoadClip.load","title":"<code>load(context, name=None, namespace=None, options=None)</code>","text":"<p>Load a clip from a file.</p> Source code in <code>client/ayon_mocha/plugins/load/load_clip.py</code> <pre><code>def load(self,\n         context: dict,\n         name: Optional[str] = None,\n         namespace: Optional[str] = None,\n         options: Optional[dict] = None) -&gt; None:\n    \"\"\"Load a clip from a file.\"\"\"\n    host: MochaProHost = registered_host()\n    project = host.get_current_project()\n    with project.undo_group():\n        file_path = self.filepath_from_context(context)\n\n        # Check if the clip with the same name already exists\n        # Mocha will load clips with the same name, but it will\n        # show in the UI just one of them, and it makes things\n        # confusing for the user.\n        clips = project.get_clips()\n        if name in clips:\n            self.log.warning(\"Clip %s already exists\", name)\n            idx = 1\n            while f\"{name}_{idx}\" in clips:\n                idx += 1\n            name = f\"{name}_{idx}\"\n\n        clip = Clip(file_path, name)\n        project.add_clip(clip, name)\n        project.new_output_clip(clip, name)\n\n        container = Container(\n            name=name,\n            namespace=namespace or \"\",\n            loader=self.__class__.__name__,\n            representation=str(context[\"representation\"][\"id\"]),\n            objectName=clip.name,\n            timestamp=time.time_ns()\n        )\n        host.add_container(container)\n        update_ui()\n        self.log.debug(\"Loaded clip: %s\", clip)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/load/load_clip.html#client.ayon_mocha.plugins.load.load_clip.LoadClip.remove","title":"<code>remove(container)</code>","text":"<p>Remove a container.</p> Source code in <code>client/ayon_mocha/plugins/load/load_clip.py</code> <pre><code>def remove(self, container: dict) -&gt; None:\n    \"\"\"Remove a container.\"\"\"\n    host: MochaProHost = registered_host()\n    project = host.get_current_project()\n\n    clips = project.get_clips()\n    clip = clips.get(container[\"objectName\"])\n    if not clip:\n        self.log.warning(\"Clip %s not found\", container[\"objectName\"])\n        return\n    del clip\n    host.remove_container(Container(**container))\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/load/load_clip.html#client.ayon_mocha.plugins.load.load_clip.LoadClip.switch","title":"<code>switch(container, context)</code>","text":"<p>Switch the image sequence on the current camera.</p> Source code in <code>client/ayon_mocha/plugins/load/load_clip.py</code> <pre><code>def switch(self, container: dict, context: dict) -&gt; None:\n    \"\"\"Switch the image sequence on the current camera.\"\"\"\n    self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/load/load_clip.html#client.ayon_mocha.plugins.load.load_clip.LoadClip.update","title":"<code>update(container, context)</code>","text":"<p>Update a container.</p> Source code in <code>client/ayon_mocha/plugins/load/load_clip.py</code> <pre><code>def update(self, container: dict, context: dict) -&gt; None:\n    \"\"\"Update a container.\"\"\"\n    host: MochaProHost = registered_host()\n\n    version_entity = context[\"version\"]\n    repre_entity = context[\"representation\"]\n\n    file_path = get_representation_path(repre_entity)\n    project = host.get_current_project()\n    clips = project.get_clips()\n    try:\n        clips[container[\"objectName\"]].relink(file_path)\n    except KeyError:\n        self.log.warning(\"Clip %s not found\", container[\"objectName\"])\n    update_ui()\n\n    container[\"representation\"] = repre_entity[\"id\"]\n    container[\"version\"] = str(version_entity[\"version\"])\n    host.add_container(Container(**container))\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/load/load_trackable_clip.html","title":"load_trackable_clip","text":"<p>Load a clip from a file as trackable clip.</p>"},{"location":"autoapi/client/ayon_mocha/plugins/load/load_trackable_clip.html#client.ayon_mocha.plugins.load.load_trackable_clip.LoadTrackableClip","title":"<code>LoadTrackableClip</code>","text":"<p>               Bases: <code>MochaLoader</code></p> <p>Load a clip from a file.</p> Source code in <code>client/ayon_mocha/plugins/load/load_trackable_clip.py</code> <pre><code>class LoadTrackableClip(MochaLoader):\n    \"\"\"Load a clip from a file.\"\"\"\n\n    label = \"Load Trackable Clip\"\n    order = -11\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    product_types: ClassVar[set[str]] = {\"*\"}\n    representations: ClassVar[set[str]] = {\"*\"}\n    extensions: ClassVar[set[str]] = {\n        ext.lstrip(\".\") for ext in IMAGE_EXTENSIONS}\n\n    def load(self,\n             context: dict,\n             name: Optional[str] = None,\n             namespace: Optional[str] = None,\n             options: Optional[dict] = None) -&gt; None:\n        \"\"\"Load a clip from a file as trackable clip.\n\n        Raises:\n            LoadError: If no trackable clip found in the project.\n\n        \"\"\"\n        host: MochaProHost = registered_host()\n        project = host.get_current_project()\n        with project.undo_group():\n\n            current_clip: Clip = project.default_trackable_clip\n            if current_clip is None:\n                msg = \"No trackable clip found in the project.\"\n                raise LoadError(msg)\n            # no way how to change clip name\n            # project.parameter([current_clip, \"name\"]).set(name)\n\n            file_path = self.filepath_from_context(context)\n            current_clip.relink(file_path)\n\n            for cnt in host.get_containers():\n                if cnt.get(\"name\") == current_clip.name:\n                    cnt[\"representation\"] = str(\n                        context[\"representation\"][\"id\"])\n                    return\n\n            container = Container(\n                name=current_clip.name,\n                namespace=namespace or \"\",\n                loader=self.__class__.__name__,\n                representation=str(context[\"representation\"][\"id\"]),\n                objectName=current_clip.name,\n                timestamp=time.time_ns()\n            )\n            host.add_container(container)\n\n    def switch(self, container: dict, context: dict) -&gt; None:\n        \"\"\"Switch the image sequence on the current camera.\"\"\"\n        self.update(container, context)\n\n    def remove(self, container: dict) -&gt; None:\n        \"\"\"Remove a container.\"\"\"\n        host: MochaProHost = registered_host()\n        project = host.get_current_project()\n\n        clips = project.get_clips()\n        clip = clips.get(container[\"objectName\"])\n        if not clip:\n            self.log.warning(\"Clip %s not found\", container[\"objectName\"])\n            return\n        del clip\n        host.remove_container(Container(**container))\n\n    def update(self, container: dict, context: dict) -&gt; None:\n        \"\"\"Update a container.\"\"\"\n        host: MochaProHost = registered_host()\n\n        version_entity = context[\"version\"]\n        repre_entity = context[\"representation\"]\n\n        file_path = get_representation_path(repre_entity)\n        project = host.get_current_project()\n        clips = project.get_clips()\n        try:\n            clips[container[\"objectName\"]].relink(file_path)\n        except KeyError:\n            self.log.warning(\"Clip %s not found\", container[\"objectName\"])\n        update_ui()\n\n        container[\"representation\"] = repre_entity[\"id\"]\n        container[\"version\"] = str(version_entity[\"version\"])\n        host.add_container(Container(**container))\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/load/load_trackable_clip.html#client.ayon_mocha.plugins.load.load_trackable_clip.LoadTrackableClip.load","title":"<code>load(context, name=None, namespace=None, options=None)</code>","text":"<p>Load a clip from a file as trackable clip.</p> <p>Raises:</p> Type Description <code>LoadError</code> <p>If no trackable clip found in the project.</p> Source code in <code>client/ayon_mocha/plugins/load/load_trackable_clip.py</code> <pre><code>def load(self,\n         context: dict,\n         name: Optional[str] = None,\n         namespace: Optional[str] = None,\n         options: Optional[dict] = None) -&gt; None:\n    \"\"\"Load a clip from a file as trackable clip.\n\n    Raises:\n        LoadError: If no trackable clip found in the project.\n\n    \"\"\"\n    host: MochaProHost = registered_host()\n    project = host.get_current_project()\n    with project.undo_group():\n\n        current_clip: Clip = project.default_trackable_clip\n        if current_clip is None:\n            msg = \"No trackable clip found in the project.\"\n            raise LoadError(msg)\n        # no way how to change clip name\n        # project.parameter([current_clip, \"name\"]).set(name)\n\n        file_path = self.filepath_from_context(context)\n        current_clip.relink(file_path)\n\n        for cnt in host.get_containers():\n            if cnt.get(\"name\") == current_clip.name:\n                cnt[\"representation\"] = str(\n                    context[\"representation\"][\"id\"])\n                return\n\n        container = Container(\n            name=current_clip.name,\n            namespace=namespace or \"\",\n            loader=self.__class__.__name__,\n            representation=str(context[\"representation\"][\"id\"]),\n            objectName=current_clip.name,\n            timestamp=time.time_ns()\n        )\n        host.add_container(container)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/load/load_trackable_clip.html#client.ayon_mocha.plugins.load.load_trackable_clip.LoadTrackableClip.remove","title":"<code>remove(container)</code>","text":"<p>Remove a container.</p> Source code in <code>client/ayon_mocha/plugins/load/load_trackable_clip.py</code> <pre><code>def remove(self, container: dict) -&gt; None:\n    \"\"\"Remove a container.\"\"\"\n    host: MochaProHost = registered_host()\n    project = host.get_current_project()\n\n    clips = project.get_clips()\n    clip = clips.get(container[\"objectName\"])\n    if not clip:\n        self.log.warning(\"Clip %s not found\", container[\"objectName\"])\n        return\n    del clip\n    host.remove_container(Container(**container))\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/load/load_trackable_clip.html#client.ayon_mocha.plugins.load.load_trackable_clip.LoadTrackableClip.switch","title":"<code>switch(container, context)</code>","text":"<p>Switch the image sequence on the current camera.</p> Source code in <code>client/ayon_mocha/plugins/load/load_trackable_clip.py</code> <pre><code>def switch(self, container: dict, context: dict) -&gt; None:\n    \"\"\"Switch the image sequence on the current camera.\"\"\"\n    self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/load/load_trackable_clip.html#client.ayon_mocha.plugins.load.load_trackable_clip.LoadTrackableClip.update","title":"<code>update(container, context)</code>","text":"<p>Update a container.</p> Source code in <code>client/ayon_mocha/plugins/load/load_trackable_clip.py</code> <pre><code>def update(self, container: dict, context: dict) -&gt; None:\n    \"\"\"Update a container.\"\"\"\n    host: MochaProHost = registered_host()\n\n    version_entity = context[\"version\"]\n    repre_entity = context[\"representation\"]\n\n    file_path = get_representation_path(repre_entity)\n    project = host.get_current_project()\n    clips = project.get_clips()\n    try:\n        clips[container[\"objectName\"]].relink(file_path)\n    except KeyError:\n        self.log.warning(\"Clip %s not found\", container[\"objectName\"])\n    update_ui()\n\n    container[\"representation\"] = repre_entity[\"id\"]\n    container[\"version\"] = str(version_entity[\"version\"])\n    host.add_container(Container(**container))\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_mocha/plugins/publish/collect_instances.html","title":"collect_instances","text":"<p>Collect instances for publishing.</p>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/collect_instances.html#client.ayon_mocha.plugins.publish.collect_instances.CollectInstances","title":"<code>CollectInstances</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect instances for publishing.</p> Source code in <code>client/ayon_mocha/plugins/publish/collect_instances.py</code> <pre><code>class CollectInstances(pyblish.api.InstancePlugin):\n    \"\"\"Collect instances for publishing.\"\"\"\n    label = \"Collect Instances\"\n    order = pyblish.api.CollectorOrder - 0.4\n    hosts: ClassVar[list[str]] = [\"mochapro\"]\n    log: Logger\n\n    def process(self, instance: pyblish.api.Instance) -&gt; None:\n        \"\"\"Process the plugin.\"\"\"\n        self.log.debug(\"Collecting data for %s\", instance)\n\n        # Define nice instance label\n        instance_node = instance.data.get(\n            \"transientData\", {}).get(\"instance_node\")\n        name = instance_node.label if instance_node else instance.name\n        label = f\"{name} ({instance.data['folderPath']})\"\n\n        # Set frame start handle and frame end handle if frame ranges are\n        # available\n        if \"frameStart\" in instance.data and \"frameEnd\" in instance.data:\n            # Enforce existence if handles\n            instance.data.setdefault(\"handleStart\", 0)\n            instance.data.setdefault(\"handleEnd\", 0)\n\n            # Compute frame start handle and end start handle\n            frame_start_handle = (\n                instance.data[\"frameStart\"] - instance.data[\"handleStart\"]\n            )\n            frame_end_handle = (\n                instance.data[\"frameEnd\"] - instance.data[\"handleEnd\"]\n            )\n            instance.data[\"frameStartHandle\"] = frame_start_handle\n            instance.data[\"frameEndHandle\"] = frame_end_handle\n\n            # Include frame range in label\n            label += f\"  [{int(frame_start_handle)}-{int(frame_end_handle)}]\"\n\n        instance.data[\"label\"] = label\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/collect_instances.html#client.ayon_mocha.plugins.publish.collect_instances.CollectInstances.process","title":"<code>process(instance)</code>","text":"<p>Process the plugin.</p> Source code in <code>client/ayon_mocha/plugins/publish/collect_instances.py</code> <pre><code>def process(self, instance: pyblish.api.Instance) -&gt; None:\n    \"\"\"Process the plugin.\"\"\"\n    self.log.debug(\"Collecting data for %s\", instance)\n\n    # Define nice instance label\n    instance_node = instance.data.get(\n        \"transientData\", {}).get(\"instance_node\")\n    name = instance_node.label if instance_node else instance.name\n    label = f\"{name} ({instance.data['folderPath']})\"\n\n    # Set frame start handle and frame end handle if frame ranges are\n    # available\n    if \"frameStart\" in instance.data and \"frameEnd\" in instance.data:\n        # Enforce existence if handles\n        instance.data.setdefault(\"handleStart\", 0)\n        instance.data.setdefault(\"handleEnd\", 0)\n\n        # Compute frame start handle and end start handle\n        frame_start_handle = (\n            instance.data[\"frameStart\"] - instance.data[\"handleStart\"]\n        )\n        frame_end_handle = (\n            instance.data[\"frameEnd\"] - instance.data[\"handleEnd\"]\n        )\n        instance.data[\"frameStartHandle\"] = frame_start_handle\n        instance.data[\"frameEndHandle\"] = frame_end_handle\n\n        # Include frame range in label\n        label += f\"  [{int(frame_start_handle)}-{int(frame_end_handle)}]\"\n\n    instance.data[\"label\"] = label\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/collect_mocha_paths.html","title":"collect_mocha_paths","text":"<p>Collect Mocha executable paths.</p>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/collect_mocha_paths.html#client.ayon_mocha.plugins.publish.collect_mocha_paths.CollectMochaPaths","title":"<code>CollectMochaPaths</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Collect Mocha Pro project.</p> Source code in <code>client/ayon_mocha/plugins/publish/collect_mocha_paths.py</code> <pre><code>class CollectMochaPaths(pyblish.api.ContextPlugin):\n    \"\"\"Collect Mocha Pro project.\"\"\"\n    order = pyblish.api.CollectorOrder - 0.45\n    label = \"Collect Mocha Pro executables\"\n    hosts: ClassVar[list[str]] = [\"mochapro\"]\n    log: Logger\n\n    def process(self, context: pyblish.api.Context) -&gt; None:\n        \"\"\"Process the plugin.\"\"\"\n        project: Project = context.data[\"project\"]\n        self.log.info(\"Collected Mocha Pro project: %s\", project)\n\n        mocha_executable_path = Path(get_mocha_exec_name(\"mochapro\"))\n        context.data[\"mocha_executable_path\"] = mocha_executable_path\n        mocha_install_dir = mocha_executable_path.parent.parent\n\n        if platform.system().lower() == \"windows\":\n            mocha_python_path = (\n                mocha_install_dir / \"python\" / \"python.exe\")\n            mocha_exporter_path = (\n                mocha_install_dir / \"python\" / \"mochaexport.py\")\n        elif platform.system().lower() == \"darwin\":\n            mocha_python_path = (\n                mocha_install_dir / \"python3\")\n            mocha_exporter_path = (\n                mocha_install_dir / \"mochaexport.py\")\n        elif platform.system().lower() == \"linux\":\n            mocha_python_path = (\n                mocha_install_dir / \"python\" / \"bin\" / \"python3\")\n            mocha_exporter_path = (\n                mocha_install_dir / \"python\" / \"mochaexport.py\")\n        else:\n            msg = f\"Unsupported platform: {platform.system()}\"\n            raise NotImplementedError(msg)\n\n        context.data[\"mocha_python_path\"] = mocha_python_path\n        context.data[\"mocha_exporter_path\"] = mocha_exporter_path\n\n        self.log.info(\"Collected Mocha Pro executable path: %s\",\n                      mocha_executable_path)\n        self.log.info(\"Collected Mocha Pro python executable path: %s\",\n                      mocha_python_path)\n        self.log.info(\"Collected Mocha Pro python export script path: %s\",\n                      mocha_exporter_path)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/collect_mocha_paths.html#client.ayon_mocha.plugins.publish.collect_mocha_paths.CollectMochaPaths.process","title":"<code>process(context)</code>","text":"<p>Process the plugin.</p> Source code in <code>client/ayon_mocha/plugins/publish/collect_mocha_paths.py</code> <pre><code>def process(self, context: pyblish.api.Context) -&gt; None:\n    \"\"\"Process the plugin.\"\"\"\n    project: Project = context.data[\"project\"]\n    self.log.info(\"Collected Mocha Pro project: %s\", project)\n\n    mocha_executable_path = Path(get_mocha_exec_name(\"mochapro\"))\n    context.data[\"mocha_executable_path\"] = mocha_executable_path\n    mocha_install_dir = mocha_executable_path.parent.parent\n\n    if platform.system().lower() == \"windows\":\n        mocha_python_path = (\n            mocha_install_dir / \"python\" / \"python.exe\")\n        mocha_exporter_path = (\n            mocha_install_dir / \"python\" / \"mochaexport.py\")\n    elif platform.system().lower() == \"darwin\":\n        mocha_python_path = (\n            mocha_install_dir / \"python3\")\n        mocha_exporter_path = (\n            mocha_install_dir / \"mochaexport.py\")\n    elif platform.system().lower() == \"linux\":\n        mocha_python_path = (\n            mocha_install_dir / \"python\" / \"bin\" / \"python3\")\n        mocha_exporter_path = (\n            mocha_install_dir / \"python\" / \"mochaexport.py\")\n    else:\n        msg = f\"Unsupported platform: {platform.system()}\"\n        raise NotImplementedError(msg)\n\n    context.data[\"mocha_python_path\"] = mocha_python_path\n    context.data[\"mocha_exporter_path\"] = mocha_exporter_path\n\n    self.log.info(\"Collected Mocha Pro executable path: %s\",\n                  mocha_executable_path)\n    self.log.info(\"Collected Mocha Pro python executable path: %s\",\n                  mocha_python_path)\n    self.log.info(\"Collected Mocha Pro python export script path: %s\",\n                  mocha_exporter_path)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/collect_mocha_project.html","title":"collect_mocha_project","text":"<p>Collect the current Mocha Pro project.</p>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/collect_mocha_project.html#client.ayon_mocha.plugins.publish.collect_mocha_project.CollectMochaProject","title":"<code>CollectMochaProject</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Inject the current working file into context.</p> <p>Foo batr baz.</p> Source code in <code>client/ayon_mocha/plugins/publish/collect_mocha_project.py</code> <pre><code>class CollectMochaProject(pyblish.api.ContextPlugin):\n    \"\"\"Inject the current working file into context.\n\n    Foo batr baz.\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.5\n    label = \"Collect Mocha Pro Project\"\n    hosts: ClassVar[list[str]] = [\"mochapro\"]\n    log: Logger\n\n    def process(self, context: pyblish.api.Context) -&gt; None:\n        \"\"\"Inject the current working file.\"\"\"\n        context.data[\"project\"] = get_current_project()\n        current_file = context.data[\"project\"].project_file\n        context.data[\"currentFile\"] = current_file\n        if not current_file:\n            self.log.warning(\n                \"Current file is not saved. Save the file before continuing.\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/collect_mocha_project.html#client.ayon_mocha.plugins.publish.collect_mocha_project.CollectMochaProject.process","title":"<code>process(context)</code>","text":"<p>Inject the current working file.</p> Source code in <code>client/ayon_mocha/plugins/publish/collect_mocha_project.py</code> <pre><code>def process(self, context: pyblish.api.Context) -&gt; None:\n    \"\"\"Inject the current working file.\"\"\"\n    context.data[\"project\"] = get_current_project()\n    current_file = context.data[\"project\"].project_file\n    context.data[\"currentFile\"] = current_file\n    if not current_file:\n        self.log.warning(\n            \"Current file is not saved. Save the file before continuing.\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/collect_shapes.html","title":"collect_shapes","text":"<p>Collect layers for shape export.</p>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/collect_shapes.html#client.ayon_mocha.plugins.publish.collect_shapes.CollectShapes","title":"<code>CollectShapes</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect trackpoint data.</p> Source code in <code>client/ayon_mocha/plugins/publish/collect_shapes.py</code> <pre><code>class CollectShapes(pyblish.api.InstancePlugin):\n    \"\"\"Collect trackpoint data.\"\"\"\n    label = \"Collect Shape Data\"\n    order = pyblish.api.CollectorOrder - 0.45\n    hosts: ClassVar[list[str]] = [\"mochapro\"]\n    families: ClassVar[list[str]] = [\"matteshapes\"]\n    log: Logger\n\n    @staticmethod\n    def new_product_name(\n        create_context: CreateContext,\n        layer_name: str,\n        product_type: str,\n        variant: str) -&gt; str:\n        \"\"\"Return the new product name.\"\"\"\n        sanitized_layer_name = layer_name.replace(\" \", \"_\")\n        variant = f\"{sanitized_layer_name}{variant.capitalize()}\"\n\n        return get_product_name(\n            project_name=create_context.project_name,\n            task_name=create_context.get_current_task_name(),\n            task_type=create_context.get_current_task_type(),\n            host_name=create_context.host_name,\n            product_type=product_type,\n            variant=variant,\n        )\n\n    def process(self, instance: pyblish.api.Instance) -&gt; None:\n        \"\"\"Process the instance.\n\n        Raises:\n            KnownPublishError: If layer mode is invalid.\n\n        \"\"\"\n        # copy creator settings to the instance itself\n        creator_attrs = instance.data[\"creator_attributes\"]\n        registered_exporters = get_shape_exporters()\n        selected_exporters = [\n            exporter\n            for exporter in registered_exporters\n            if exporter.id in creator_attrs[\"exporter\"]\n        ]\n\n        instance.data[\"use_exporters\"] = selected_exporters\n        project: Project = instance.context.data[\"project\"]\n        layers: list[Layer] = []\n        if creator_attrs[\"layer_mode\"] == \"selected\":\n            layers.extend(\n                project.layers[selected_layer_idx]\n                for selected_layer_idx in creator_attrs[\"layers\"]\n            )\n        elif creator_attrs[\"layer_mode\"] == \"all\":\n            layers = project.layers\n        else:\n            msg = f\"Invalid layer mode: {creator_attrs['layer_mode']}\"\n            raise KnownPublishError(msg)\n\n        for layer in layers:\n            new_instance = instance.context.create_instance(\n                f\"{instance.name} - {layer.name}\"\n            )\n            for k, v in instance.data.items():\n                # this is needed because the data is not always\n                # \"deepcopyable\".\n                try:\n                    new_instance.data[k] = deepcopy(v)\n                except TypeError:  # noqa: PERF203\n                    new_instance.data[k] = v\n\n            # new_instance.data = instance.data\n            new_instance.data[\"label\"] = f\"{instance.name} ({layer.name})\"\n            new_instance.data[\"name\"] = f\"{instance.name}_{layer.name}\"\n            new_instance.data[\"productName\"] = self.new_product_name(\n                instance.context.data[\"create_context\"],\n                layer.name,\n                instance.data[\"productType\"],\n                instance.data[\"variant\"],\n            )\n            self.set_layer_data_on_instance(new_instance, layer)\n        if layers:\n            instance.context.remove(instance)\n\n    @staticmethod\n    def set_layer_data_on_instance(\n            instance: pyblish.api.Instance, layer: Layer) -&gt; None:\n        \"\"\"Set data on instance.\"\"\"\n        instance.data[\"layer\"] = layer\n        instance.data[\"frameStart\"] = layer.in_point()\n        instance.data[\"frameEnd\"] = layer.out_point()\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/collect_shapes.html#client.ayon_mocha.plugins.publish.collect_shapes.CollectShapes.new_product_name","title":"<code>new_product_name(create_context, layer_name, product_type, variant)</code>  <code>staticmethod</code>","text":"<p>Return the new product name.</p> Source code in <code>client/ayon_mocha/plugins/publish/collect_shapes.py</code> <pre><code>@staticmethod\ndef new_product_name(\n    create_context: CreateContext,\n    layer_name: str,\n    product_type: str,\n    variant: str) -&gt; str:\n    \"\"\"Return the new product name.\"\"\"\n    sanitized_layer_name = layer_name.replace(\" \", \"_\")\n    variant = f\"{sanitized_layer_name}{variant.capitalize()}\"\n\n    return get_product_name(\n        project_name=create_context.project_name,\n        task_name=create_context.get_current_task_name(),\n        task_type=create_context.get_current_task_type(),\n        host_name=create_context.host_name,\n        product_type=product_type,\n        variant=variant,\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/collect_shapes.html#client.ayon_mocha.plugins.publish.collect_shapes.CollectShapes.process","title":"<code>process(instance)</code>","text":"<p>Process the instance.</p> <p>Raises:</p> Type Description <code>KnownPublishError</code> <p>If layer mode is invalid.</p> Source code in <code>client/ayon_mocha/plugins/publish/collect_shapes.py</code> <pre><code>def process(self, instance: pyblish.api.Instance) -&gt; None:\n    \"\"\"Process the instance.\n\n    Raises:\n        KnownPublishError: If layer mode is invalid.\n\n    \"\"\"\n    # copy creator settings to the instance itself\n    creator_attrs = instance.data[\"creator_attributes\"]\n    registered_exporters = get_shape_exporters()\n    selected_exporters = [\n        exporter\n        for exporter in registered_exporters\n        if exporter.id in creator_attrs[\"exporter\"]\n    ]\n\n    instance.data[\"use_exporters\"] = selected_exporters\n    project: Project = instance.context.data[\"project\"]\n    layers: list[Layer] = []\n    if creator_attrs[\"layer_mode\"] == \"selected\":\n        layers.extend(\n            project.layers[selected_layer_idx]\n            for selected_layer_idx in creator_attrs[\"layers\"]\n        )\n    elif creator_attrs[\"layer_mode\"] == \"all\":\n        layers = project.layers\n    else:\n        msg = f\"Invalid layer mode: {creator_attrs['layer_mode']}\"\n        raise KnownPublishError(msg)\n\n    for layer in layers:\n        new_instance = instance.context.create_instance(\n            f\"{instance.name} - {layer.name}\"\n        )\n        for k, v in instance.data.items():\n            # this is needed because the data is not always\n            # \"deepcopyable\".\n            try:\n                new_instance.data[k] = deepcopy(v)\n            except TypeError:  # noqa: PERF203\n                new_instance.data[k] = v\n\n        # new_instance.data = instance.data\n        new_instance.data[\"label\"] = f\"{instance.name} ({layer.name})\"\n        new_instance.data[\"name\"] = f\"{instance.name}_{layer.name}\"\n        new_instance.data[\"productName\"] = self.new_product_name(\n            instance.context.data[\"create_context\"],\n            layer.name,\n            instance.data[\"productType\"],\n            instance.data[\"variant\"],\n        )\n        self.set_layer_data_on_instance(new_instance, layer)\n    if layers:\n        instance.context.remove(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/collect_shapes.html#client.ayon_mocha.plugins.publish.collect_shapes.CollectShapes.set_layer_data_on_instance","title":"<code>set_layer_data_on_instance(instance, layer)</code>  <code>staticmethod</code>","text":"<p>Set data on instance.</p> Source code in <code>client/ayon_mocha/plugins/publish/collect_shapes.py</code> <pre><code>@staticmethod\ndef set_layer_data_on_instance(\n        instance: pyblish.api.Instance, layer: Layer) -&gt; None:\n    \"\"\"Set data on instance.\"\"\"\n    instance.data[\"layer\"] = layer\n    instance.data[\"frameStart\"] = layer.in_point()\n    instance.data[\"frameEnd\"] = layer.out_point()\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/collect_trackpoints.html","title":"collect_trackpoints","text":"<p>Collect instances for publishing.</p>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/collect_trackpoints.html#client.ayon_mocha.plugins.publish.collect_trackpoints.CollectTrackpoints","title":"<code>CollectTrackpoints</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect trackpoint data.</p> Source code in <code>client/ayon_mocha/plugins/publish/collect_trackpoints.py</code> <pre><code>class CollectTrackpoints(pyblish.api.InstancePlugin):\n    \"\"\"Collect trackpoint data.\"\"\"\n    label = \"Collect Tracking Data\"\n    order = pyblish.api.CollectorOrder - 0.45\n    hosts: ClassVar[list[str]] = [\"mochapro\"]\n    families: ClassVar[list[str]] = [\"trackpoints\"]\n    log: Logger\n\n    @staticmethod\n    def new_product_name(\n        create_context: CreateContext,\n        layer_name: str,\n        product_type: str,\n        variant: str) -&gt; str:\n        \"\"\"Return the new product name.\"\"\"\n        sanitized_layer_name = layer_name.replace(\" \", \"_\")\n        variant = f\"{sanitized_layer_name}{variant.capitalize()}\"\n\n        return get_product_name(\n            project_name=create_context.project_name,\n            task_name=create_context.get_current_task_name(),\n            task_type=create_context.get_current_task_type(),\n            host_name=create_context.host_name,\n            product_type=product_type,\n            variant=variant,\n        )\n\n    def process(self, instance: pyblish.api.Instance) -&gt; None:\n        \"\"\"Process the instance.\n\n        Raises:\n            KnownPublishError: If the layer mode is invalid.\n\n        \"\"\"\n        # copy creator settings to the instance itself\n        creator_attrs = instance.data[\"creator_attributes\"]\n        registered_exporters = get_tracking_exporters()\n        selected_exporters = [\n            exporter\n            for exporter in registered_exporters\n            if exporter.id in creator_attrs[\"exporter\"]\n        ]\n\n        instance.data[\"use_exporters\"] = selected_exporters\n        instance.data[\"exporter_options\"] = {\n            \"invert\": creator_attrs[\"invert\"],\n            \"frame_time\": creator_attrs[\"frame_time\"],\n            \"remove_lens_distortion\": creator_attrs[\"remove_lens_distortion\"],\n        }\n\n        project: Project = instance.context.data[\"project\"]\n        layers: list[Layer] = []\n        if creator_attrs[\"layer_mode\"] == \"selected\":\n            layers.extend(\n                project.layers[selected_layer_idx]\n                for selected_layer_idx in creator_attrs[\"layers\"]\n            )\n        elif creator_attrs[\"layer_mode\"] == \"all\":\n            layers = project.layers\n        else:\n            msg = f\"Invalid layer mode: {creator_attrs['layer_mode']}\"\n            raise KnownPublishError(msg)\n\n        for layer in layers:\n            new_instance = instance.context.create_instance(\n                f\"{instance.name}_{layer.name}\"\n            )\n            for k, v in instance.data.items():\n                # this is needed because the data is not always\n                # \"deepcopyable\".\n                try:\n                    new_instance.data[k] = deepcopy(v)\n                except TypeError:  # noqa: PERF203\n                    new_instance.data[k] = v\n\n            # new_instance.data = instance.data\n            new_instance.data[\"label\"] = f\"{instance.name} ({layer.name})\"\n            new_instance.data[\"name\"] = f\"{instance.name}_{layer.name}\"\n            new_instance.data[\"productName\"] = self.new_product_name(\n                instance.context.data[\"create_context\"],\n                layer.name,\n                instance.data[\"productType\"],\n                instance.data[\"variant\"],\n            )\n            self.set_layer_data_on_instance(new_instance, layer)\n\n        instance.context.remove(instance)\n\n    @staticmethod\n    def set_layer_data_on_instance(\n            instance: pyblish.api.Instance, layer: Layer) -&gt; None:\n        \"\"\"Set data on instance.\"\"\"\n        instance.data[\"layer\"] = layer\n        instance.data[\"frameStart\"] = layer.in_point()\n        instance.data[\"frameEnd\"] = layer.out_point()\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/collect_trackpoints.html#client.ayon_mocha.plugins.publish.collect_trackpoints.CollectTrackpoints.new_product_name","title":"<code>new_product_name(create_context, layer_name, product_type, variant)</code>  <code>staticmethod</code>","text":"<p>Return the new product name.</p> Source code in <code>client/ayon_mocha/plugins/publish/collect_trackpoints.py</code> <pre><code>@staticmethod\ndef new_product_name(\n    create_context: CreateContext,\n    layer_name: str,\n    product_type: str,\n    variant: str) -&gt; str:\n    \"\"\"Return the new product name.\"\"\"\n    sanitized_layer_name = layer_name.replace(\" \", \"_\")\n    variant = f\"{sanitized_layer_name}{variant.capitalize()}\"\n\n    return get_product_name(\n        project_name=create_context.project_name,\n        task_name=create_context.get_current_task_name(),\n        task_type=create_context.get_current_task_type(),\n        host_name=create_context.host_name,\n        product_type=product_type,\n        variant=variant,\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/collect_trackpoints.html#client.ayon_mocha.plugins.publish.collect_trackpoints.CollectTrackpoints.process","title":"<code>process(instance)</code>","text":"<p>Process the instance.</p> <p>Raises:</p> Type Description <code>KnownPublishError</code> <p>If the layer mode is invalid.</p> Source code in <code>client/ayon_mocha/plugins/publish/collect_trackpoints.py</code> <pre><code>def process(self, instance: pyblish.api.Instance) -&gt; None:\n    \"\"\"Process the instance.\n\n    Raises:\n        KnownPublishError: If the layer mode is invalid.\n\n    \"\"\"\n    # copy creator settings to the instance itself\n    creator_attrs = instance.data[\"creator_attributes\"]\n    registered_exporters = get_tracking_exporters()\n    selected_exporters = [\n        exporter\n        for exporter in registered_exporters\n        if exporter.id in creator_attrs[\"exporter\"]\n    ]\n\n    instance.data[\"use_exporters\"] = selected_exporters\n    instance.data[\"exporter_options\"] = {\n        \"invert\": creator_attrs[\"invert\"],\n        \"frame_time\": creator_attrs[\"frame_time\"],\n        \"remove_lens_distortion\": creator_attrs[\"remove_lens_distortion\"],\n    }\n\n    project: Project = instance.context.data[\"project\"]\n    layers: list[Layer] = []\n    if creator_attrs[\"layer_mode\"] == \"selected\":\n        layers.extend(\n            project.layers[selected_layer_idx]\n            for selected_layer_idx in creator_attrs[\"layers\"]\n        )\n    elif creator_attrs[\"layer_mode\"] == \"all\":\n        layers = project.layers\n    else:\n        msg = f\"Invalid layer mode: {creator_attrs['layer_mode']}\"\n        raise KnownPublishError(msg)\n\n    for layer in layers:\n        new_instance = instance.context.create_instance(\n            f\"{instance.name}_{layer.name}\"\n        )\n        for k, v in instance.data.items():\n            # this is needed because the data is not always\n            # \"deepcopyable\".\n            try:\n                new_instance.data[k] = deepcopy(v)\n            except TypeError:  # noqa: PERF203\n                new_instance.data[k] = v\n\n        # new_instance.data = instance.data\n        new_instance.data[\"label\"] = f\"{instance.name} ({layer.name})\"\n        new_instance.data[\"name\"] = f\"{instance.name}_{layer.name}\"\n        new_instance.data[\"productName\"] = self.new_product_name(\n            instance.context.data[\"create_context\"],\n            layer.name,\n            instance.data[\"productType\"],\n            instance.data[\"variant\"],\n        )\n        self.set_layer_data_on_instance(new_instance, layer)\n\n    instance.context.remove(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/collect_trackpoints.html#client.ayon_mocha.plugins.publish.collect_trackpoints.CollectTrackpoints.set_layer_data_on_instance","title":"<code>set_layer_data_on_instance(instance, layer)</code>  <code>staticmethod</code>","text":"<p>Set data on instance.</p> Source code in <code>client/ayon_mocha/plugins/publish/collect_trackpoints.py</code> <pre><code>@staticmethod\ndef set_layer_data_on_instance(\n        instance: pyblish.api.Instance, layer: Layer) -&gt; None:\n    \"\"\"Set data on instance.\"\"\"\n    instance.data[\"layer\"] = layer\n    instance.data[\"frameStart\"] = layer.in_point()\n    instance.data[\"frameEnd\"] = layer.out_point()\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/collect_workfile.html","title":"collect_workfile","text":"<p>Collect the current working file.</p>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/collect_workfile.html#client.ayon_mocha.plugins.publish.collect_workfile.CollectWorkfileData","title":"<code>CollectWorkfileData</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect Mocha workfile data.</p> Source code in <code>client/ayon_mocha/plugins/publish/collect_workfile.py</code> <pre><code>class CollectWorkfileData(pyblish.api.InstancePlugin):\n    \"\"\"Collect Mocha workfile data.\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.01\n    label = \"Mocha Workfile\"\n    families: ClassVar[list[str]] = [\"workfile\"]\n\n    def process(self, instance: pyblish.api.Instance) -&gt; None:  # noqa: PLR6301\n        \"\"\"Inject the current working file.\"\"\"\n        context = instance.context\n        current_file = instance.context.data[\"currentFile\"]\n        folder, file = os.path.split(current_file)\n        _, ext = os.path.splitext(file)\n\n        data = {\n            \"setMembers\": [current_file],\n            \"frameStart\": context.data[\"frameStart\"],\n            \"frameEnd\": context.data[\"frameEnd\"],\n            \"handleStart\": context.data[\"handleStart\"],\n            \"handleEnd\": context.data[\"handleEnd\"],\n            \"representations\": [{\n                \"name\": ext.lstrip(\".\"),\n                \"ext\": ext.lstrip(\".\"),\n                \"files\": file,\n                \"stagingDir\": folder,\n            }]}\n\n        instance.data.update(data)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/collect_workfile.html#client.ayon_mocha.plugins.publish.collect_workfile.CollectWorkfileData.process","title":"<code>process(instance)</code>","text":"<p>Inject the current working file.</p> Source code in <code>client/ayon_mocha/plugins/publish/collect_workfile.py</code> <pre><code>def process(self, instance: pyblish.api.Instance) -&gt; None:  # noqa: PLR6301\n    \"\"\"Inject the current working file.\"\"\"\n    context = instance.context\n    current_file = instance.context.data[\"currentFile\"]\n    folder, file = os.path.split(current_file)\n    _, ext = os.path.splitext(file)\n\n    data = {\n        \"setMembers\": [current_file],\n        \"frameStart\": context.data[\"frameStart\"],\n        \"frameEnd\": context.data[\"frameEnd\"],\n        \"handleStart\": context.data[\"handleStart\"],\n        \"handleEnd\": context.data[\"handleEnd\"],\n        \"representations\": [{\n            \"name\": ext.lstrip(\".\"),\n            \"ext\": ext.lstrip(\".\"),\n            \"files\": file,\n            \"stagingDir\": folder,\n        }]}\n\n    instance.data.update(data)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/export_shapes.html","title":"export_shapes","text":"<p>Extract tracking points from Mocha.</p>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/export_shapes.html#client.ayon_mocha.plugins.publish.export_shapes.ExportShape","title":"<code>ExportShape</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Export shapes.</p> Source code in <code>client/ayon_mocha/plugins/publish/export_shapes.py</code> <pre><code>class ExportShape(publish.Extractor):\n    \"\"\"Export shapes.\"\"\"\n\n    label = \"Export Shapes\"\n    families: ClassVar[list[str]] = [\"matteshapes\"]\n    log: Logger\n\n    def process(self, instance: pyblish.api.Instance) -&gt; None:\n        \"\"\"Process the instance.\"\"\"\n        dir_path = Path(self.staging_dir(instance))\n        project: Project = instance.context.data[\"project\"]\n        layer: Layer = instance.data[\"layer\"]\n\n        process_info = ExporterProcessInfo(\n            mocha_python_path=instance.context.data[\"mocha_python_path\"],\n            mocha_exporter_path=instance.context.data[\"mocha_exporter_path\"],\n            current_project_path=instance.context.data[\"currentFile\"],\n            staging_dir=dir_path,\n            options={}\n        )\n\n        outputs = self.export(\n            instance.data[\"productName\"],\n            project,\n            instance.data[\"use_exporters\"],\n            layer,\n            process_info,\n        )\n\n        representations = self.process_outputs_to_representations(\n            outputs, instance)\n\n        instance.data.setdefault(\n            \"representations\", []).extend(representations)\n\n        self.log.debug(instance.data[\"representations\"])\n\n    def process_outputs_to_representations(\n            self, outputs: list[dict],\n            instance: pyblish.api.Instance) -&gt; list[dict]:\n        \"\"\"Process the output to representations.\n\n        This will process output from the exporters to representations.\n\n        Args:\n            outputs (list[dict]): list of outputs.\n            instance (pyblish.api.Instance): instance.\n\n        Returns:\n            list[dict]: list of representations.\n\n        Raises:\n            KnownPublishError: if the exporter produced multiple\n                sequences and single files.\n\n        \"\"\"\n        representations = []\n        staging_dir = Path(self.staging_dir(instance))\n\n        for output in outputs:\n            # if there are multiple files in one representation\n            # we need to check if it is sequence or not as current\n            # integration does not support multiple files that are not\n            # in sequences.\n            repre_name = self._exporter_name_to_representation_name(\n                output[\"name\"])\n\n            cols, rems = clique.assemble(output[\"files\"])\n            if rems and cols:\n                # there are both sequences and single files\n                if cols &gt; 1:\n                    # the extractor produced multiple sequences\n                    # and single files. This is not supported now\n                    # due to the complexity.\n                    msg = (\"The exporter produced multiple sequences \"\n                           \"and single files. This is not supported.\")\n                    raise KnownPublishError(msg)\n                output_files = cols[0]\n                for reminder in rems:\n                    self.add_to_resources(\n                        Path(self.staging_dir(instance)) / reminder, instance)\n                representations.append({\n                    \"name\": repre_name,\n                    \"ext\": output[\"ext\"],\n                    \"files\": output_files,\n                    \"stagingDir\": output[\"stagingDir\"],\n                    \"outputName\": output[\"outputName\"],\n                })\n            if rems and not cols:\n                if len(rems) &gt; 1:\n                    # if there are only non-sequence files\n                    for reminder in rems:\n                        self.add_to_resources(\n                            Path(self.staging_dir(instance)) / reminder, instance)  # noqa: E501\n                    manifest_file = self._create_manifest_file(\n                        staging_dir, rems, repre_name)\n                    representations.append({\n                        \"name\": repre_name,\n                        \"ext\": output[\"ext\"],\n                        \"files\": manifest_file,\n                        \"stagingDir\": output[\"stagingDir\"],\n                        \"outputName\": output[\"outputName\"],\n                    })\n                else:\n                    # if there is only one non-sequence file\n                    representations.append({\n                        \"name\": repre_name,\n                        \"ext\": output[\"ext\"],\n                        \"files\": rems[0],\n                        \"stagingDir\": output[\"stagingDir\"],\n                        \"outputName\": output[\"outputName\"],\n                    })\n            if cols and not rems:\n                # if there are only sequences\n                if len(cols) &gt; 1:\n                    # the extractor produced multiple sequences\n                    # and single files. This is not supported now\n                    # due to the complexity.\n                    msg = (\"The exporter produced multiple sequences \"\n                           \"and single files. This is not supported.\")\n                    raise KnownPublishError(msg)\n                representations.append({\n                    \"name\": repre_name,\n                    \"ext\": output[\"ext\"],\n                    \"files\": list(cols[0]),\n                    \"stagingDir\": output[\"stagingDir\"],\n                    \"outputName\": output[\"outputName\"],\n                })\n        return representations\n\n    @staticmethod\n    def _create_manifest_file(\n            staging_dir: Path, files: list[str], repre_name: str) -&gt; str:\n        \"\"\"Create a manifest file.\n\n        This will put all the files to a manifest file that\n        will be used as a representation. This is because the\n        current integration does not support multiple files\n        that are not in sequences.\n\n        Args:\n            staging_dir (Path): staging directory.\n            files (list[str]): list of files.\n            repre_name (str): representation name.\n\n        Returns:\n            str: manifest file name.\n\n        \"\"\"\n        file_name = f\"{repre_name}.manifest\"\n        manifest_file = staging_dir / file_name\n        with open(manifest_file, \"w\", encoding=\"utf-8\") as file:\n            file.writelines(files)\n        return file_name\n\n    def export(\n            self,\n            product_name: str,\n            project: Project,\n            exporters: list[ExporterInfo],\n            layer: Layer,\n            process_info: ExporterProcessInfo\n        ) -&gt; list[dict]:\n        \"\"\"Export the instance.\n\n        This is using in-process export but since the export\n        times are pretty fast, it's easier and probably\n        faster than using the external export.\n\n        Args:\n            product_name (str): used for naming the resulting\n                files.\n            project (Project): Mocha project.\n            exporters (list[ExporterInfo]): exporters to use.\n            layer (Layer): layer to export.\n            process_info (ExporterProcessInfo): process information.\n\n        Returns:\n            list[dict]: list of exported files.\n\n        Raises:\n            KnownPublishError: if the exporter name is not found\n\n        \"\"\"\n        views = [view_info.name for view_info in project.views]\n        views_to_export: set[View] = {\n            View(num)\n            for num, view_info in enumerate(project.views)\n            if view_info.name in views or view_info.abbr in views\n        }\n\n        output: list[dict] = []\n        for exporter_info in exporters:\n            exporter_name = exporter_info.label\n            if not exporter_name:\n                msg = (\"Cannot get exporter name \"\n                       f\"from {exporter_info.label} exporter.\")\n                raise KnownPublishError(msg)\n\n            exporter_short_hash = exporter_info.id[:8]\n\n            version = get_mocha_version() or \"2024\"\n\n            # exporters were rewritten in 2025. For older version\n            # we need to parse the file extension from the exporter\n            # label. We add it here so it is later on used from the\n            # resulted file name.\n            file_name = f\"{product_name}_{exporter_short_hash}\"\n            if int(version.split(\".\")[0]) &lt; MOCHA_2025:\n                ext = ExportShape._get_extension(exporter_info)\n                if not ext:\n                    msg = (\"Cannot get extension \"\n                           f\"from {exporter_info.label} exporter.\")\n                    raise KnownPublishError(msg)\n                file_name += f\".{ExportShape._get_extension(exporter_info)}\"\n\n            shapes_file_path = (\n                    process_info.staging_dir / file_name\n            )\n\n            # this is for some reason needed to pass it to `do_render()`\n            views_typed: List[View] = list(views_to_export)\n            layers_typed: List[Layer] = [layer]\n            result = exporter_info.exporter.do_export(\n                project,\n                layers_typed,\n                shapes_file_path.as_posix(),\n                views_typed\n            )\n            self.log.debug(\n                \"Selected exporter: %s\", exporter_name)\n            self.log.debug(\n                \"Exporting to: %s\", shapes_file_path)\n\n            if not result:\n                msg = f\"Export failed for {exporter_name}.\"\n                raise KnownPublishError(msg)\n\n            output_files = []\n            ext = None\n            for k, v in result.items():\n                Path(k).write_bytes(v)\n                output_files.append(Path(k).name)\n\n                if ext is None:\n                    ext = Path(k).suffix[1:]\n\n            output.append({\n                \"name\": exporter_info.label,\n                \"ext\": ext,\n                \"files\": output_files,\n                \"stagingDir\": process_info.staging_dir.as_posix(),\n                \"outputName\": exporter_short_hash,\n            })\n\n        return output\n\n    def add_to_resources(\n            self, path: Path, instance: pyblish.api.Instance) -&gt; None:\n        \"\"\"Add the path to the resources.\"\"\"\n        self.log.debug(\"Adding to resources: %s\", path)\n\n        publish_dir_path = Path(instance.data[\"publishDir\"])\n        instance.data[\"transfers\"].append(\n            [path.as_posix(), (publish_dir_path / path.name).as_posix()])\n\n    @staticmethod\n    def _get_extension(exporter_info: ExporterInfo) -&gt; Optional[str]:\n        \"\"\"Get the extension of the exporter.\n\n        This is used only if the exporter name contains the extension.\n        From Mocha 2025 the extension is not part of the exporter name\n        anymore.\n\n        Returns:\n            Optional[str]: extension of the exporter if detected.\n\n        \"\"\"\n        match = re.search(EXTENSION_PATTERN, exporter_info.label)\n        return match[\"ext\"] if match else None\n\n    @staticmethod\n    def _exporter_name_to_representation_name(\n            exporter_name: str) -&gt; str:\n        \"\"\"Convert the exporter name to representation name.\n\n        Args:\n            exporter_name (str): exporter name.\n\n        Returns:\n            str: exporter representation name.\n\n        \"\"\"\n        version = get_mocha_version() or \"2024\"\n        try:\n            mapping = EXPORTER_MAPPING[\"shape\"][version]\n        except KeyError:\n            mapping = EXPORTER_MAPPING[\"shape\"][\"2024.5\"]\n\n        return mapping.get(\n            exporter_name, exporter_name)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/export_shapes.html#client.ayon_mocha.plugins.publish.export_shapes.ExportShape.add_to_resources","title":"<code>add_to_resources(path, instance)</code>","text":"<p>Add the path to the resources.</p> Source code in <code>client/ayon_mocha/plugins/publish/export_shapes.py</code> <pre><code>def add_to_resources(\n        self, path: Path, instance: pyblish.api.Instance) -&gt; None:\n    \"\"\"Add the path to the resources.\"\"\"\n    self.log.debug(\"Adding to resources: %s\", path)\n\n    publish_dir_path = Path(instance.data[\"publishDir\"])\n    instance.data[\"transfers\"].append(\n        [path.as_posix(), (publish_dir_path / path.name).as_posix()])\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/export_shapes.html#client.ayon_mocha.plugins.publish.export_shapes.ExportShape.export","title":"<code>export(product_name, project, exporters, layer, process_info)</code>","text":"<p>Export the instance.</p> <p>This is using in-process export but since the export times are pretty fast, it's easier and probably faster than using the external export.</p> <p>Parameters:</p> Name Type Description Default <code>product_name</code> <code>str</code> <p>used for naming the resulting files.</p> required <code>project</code> <code>Project</code> <p>Mocha project.</p> required <code>exporters</code> <code>list[ExporterInfo]</code> <p>exporters to use.</p> required <code>layer</code> <code>Layer</code> <p>layer to export.</p> required <code>process_info</code> <code>ExporterProcessInfo</code> <p>process information.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: list of exported files.</p> <p>Raises:</p> Type Description <code>KnownPublishError</code> <p>if the exporter name is not found</p> Source code in <code>client/ayon_mocha/plugins/publish/export_shapes.py</code> <pre><code>def export(\n        self,\n        product_name: str,\n        project: Project,\n        exporters: list[ExporterInfo],\n        layer: Layer,\n        process_info: ExporterProcessInfo\n    ) -&gt; list[dict]:\n    \"\"\"Export the instance.\n\n    This is using in-process export but since the export\n    times are pretty fast, it's easier and probably\n    faster than using the external export.\n\n    Args:\n        product_name (str): used for naming the resulting\n            files.\n        project (Project): Mocha project.\n        exporters (list[ExporterInfo]): exporters to use.\n        layer (Layer): layer to export.\n        process_info (ExporterProcessInfo): process information.\n\n    Returns:\n        list[dict]: list of exported files.\n\n    Raises:\n        KnownPublishError: if the exporter name is not found\n\n    \"\"\"\n    views = [view_info.name for view_info in project.views]\n    views_to_export: set[View] = {\n        View(num)\n        for num, view_info in enumerate(project.views)\n        if view_info.name in views or view_info.abbr in views\n    }\n\n    output: list[dict] = []\n    for exporter_info in exporters:\n        exporter_name = exporter_info.label\n        if not exporter_name:\n            msg = (\"Cannot get exporter name \"\n                   f\"from {exporter_info.label} exporter.\")\n            raise KnownPublishError(msg)\n\n        exporter_short_hash = exporter_info.id[:8]\n\n        version = get_mocha_version() or \"2024\"\n\n        # exporters were rewritten in 2025. For older version\n        # we need to parse the file extension from the exporter\n        # label. We add it here so it is later on used from the\n        # resulted file name.\n        file_name = f\"{product_name}_{exporter_short_hash}\"\n        if int(version.split(\".\")[0]) &lt; MOCHA_2025:\n            ext = ExportShape._get_extension(exporter_info)\n            if not ext:\n                msg = (\"Cannot get extension \"\n                       f\"from {exporter_info.label} exporter.\")\n                raise KnownPublishError(msg)\n            file_name += f\".{ExportShape._get_extension(exporter_info)}\"\n\n        shapes_file_path = (\n                process_info.staging_dir / file_name\n        )\n\n        # this is for some reason needed to pass it to `do_render()`\n        views_typed: List[View] = list(views_to_export)\n        layers_typed: List[Layer] = [layer]\n        result = exporter_info.exporter.do_export(\n            project,\n            layers_typed,\n            shapes_file_path.as_posix(),\n            views_typed\n        )\n        self.log.debug(\n            \"Selected exporter: %s\", exporter_name)\n        self.log.debug(\n            \"Exporting to: %s\", shapes_file_path)\n\n        if not result:\n            msg = f\"Export failed for {exporter_name}.\"\n            raise KnownPublishError(msg)\n\n        output_files = []\n        ext = None\n        for k, v in result.items():\n            Path(k).write_bytes(v)\n            output_files.append(Path(k).name)\n\n            if ext is None:\n                ext = Path(k).suffix[1:]\n\n        output.append({\n            \"name\": exporter_info.label,\n            \"ext\": ext,\n            \"files\": output_files,\n            \"stagingDir\": process_info.staging_dir.as_posix(),\n            \"outputName\": exporter_short_hash,\n        })\n\n    return output\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/export_shapes.html#client.ayon_mocha.plugins.publish.export_shapes.ExportShape.process","title":"<code>process(instance)</code>","text":"<p>Process the instance.</p> Source code in <code>client/ayon_mocha/plugins/publish/export_shapes.py</code> <pre><code>def process(self, instance: pyblish.api.Instance) -&gt; None:\n    \"\"\"Process the instance.\"\"\"\n    dir_path = Path(self.staging_dir(instance))\n    project: Project = instance.context.data[\"project\"]\n    layer: Layer = instance.data[\"layer\"]\n\n    process_info = ExporterProcessInfo(\n        mocha_python_path=instance.context.data[\"mocha_python_path\"],\n        mocha_exporter_path=instance.context.data[\"mocha_exporter_path\"],\n        current_project_path=instance.context.data[\"currentFile\"],\n        staging_dir=dir_path,\n        options={}\n    )\n\n    outputs = self.export(\n        instance.data[\"productName\"],\n        project,\n        instance.data[\"use_exporters\"],\n        layer,\n        process_info,\n    )\n\n    representations = self.process_outputs_to_representations(\n        outputs, instance)\n\n    instance.data.setdefault(\n        \"representations\", []).extend(representations)\n\n    self.log.debug(instance.data[\"representations\"])\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/export_shapes.html#client.ayon_mocha.plugins.publish.export_shapes.ExportShape.process_outputs_to_representations","title":"<code>process_outputs_to_representations(outputs, instance)</code>","text":"<p>Process the output to representations.</p> <p>This will process output from the exporters to representations.</p> <p>Parameters:</p> Name Type Description Default <code>outputs</code> <code>list[dict]</code> <p>list of outputs.</p> required <code>instance</code> <code>Instance</code> <p>instance.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: list of representations.</p> <p>Raises:</p> Type Description <code>KnownPublishError</code> <p>if the exporter produced multiple sequences and single files.</p> Source code in <code>client/ayon_mocha/plugins/publish/export_shapes.py</code> <pre><code>def process_outputs_to_representations(\n        self, outputs: list[dict],\n        instance: pyblish.api.Instance) -&gt; list[dict]:\n    \"\"\"Process the output to representations.\n\n    This will process output from the exporters to representations.\n\n    Args:\n        outputs (list[dict]): list of outputs.\n        instance (pyblish.api.Instance): instance.\n\n    Returns:\n        list[dict]: list of representations.\n\n    Raises:\n        KnownPublishError: if the exporter produced multiple\n            sequences and single files.\n\n    \"\"\"\n    representations = []\n    staging_dir = Path(self.staging_dir(instance))\n\n    for output in outputs:\n        # if there are multiple files in one representation\n        # we need to check if it is sequence or not as current\n        # integration does not support multiple files that are not\n        # in sequences.\n        repre_name = self._exporter_name_to_representation_name(\n            output[\"name\"])\n\n        cols, rems = clique.assemble(output[\"files\"])\n        if rems and cols:\n            # there are both sequences and single files\n            if cols &gt; 1:\n                # the extractor produced multiple sequences\n                # and single files. This is not supported now\n                # due to the complexity.\n                msg = (\"The exporter produced multiple sequences \"\n                       \"and single files. This is not supported.\")\n                raise KnownPublishError(msg)\n            output_files = cols[0]\n            for reminder in rems:\n                self.add_to_resources(\n                    Path(self.staging_dir(instance)) / reminder, instance)\n            representations.append({\n                \"name\": repre_name,\n                \"ext\": output[\"ext\"],\n                \"files\": output_files,\n                \"stagingDir\": output[\"stagingDir\"],\n                \"outputName\": output[\"outputName\"],\n            })\n        if rems and not cols:\n            if len(rems) &gt; 1:\n                # if there are only non-sequence files\n                for reminder in rems:\n                    self.add_to_resources(\n                        Path(self.staging_dir(instance)) / reminder, instance)  # noqa: E501\n                manifest_file = self._create_manifest_file(\n                    staging_dir, rems, repre_name)\n                representations.append({\n                    \"name\": repre_name,\n                    \"ext\": output[\"ext\"],\n                    \"files\": manifest_file,\n                    \"stagingDir\": output[\"stagingDir\"],\n                    \"outputName\": output[\"outputName\"],\n                })\n            else:\n                # if there is only one non-sequence file\n                representations.append({\n                    \"name\": repre_name,\n                    \"ext\": output[\"ext\"],\n                    \"files\": rems[0],\n                    \"stagingDir\": output[\"stagingDir\"],\n                    \"outputName\": output[\"outputName\"],\n                })\n        if cols and not rems:\n            # if there are only sequences\n            if len(cols) &gt; 1:\n                # the extractor produced multiple sequences\n                # and single files. This is not supported now\n                # due to the complexity.\n                msg = (\"The exporter produced multiple sequences \"\n                       \"and single files. This is not supported.\")\n                raise KnownPublishError(msg)\n            representations.append({\n                \"name\": repre_name,\n                \"ext\": output[\"ext\"],\n                \"files\": list(cols[0]),\n                \"stagingDir\": output[\"stagingDir\"],\n                \"outputName\": output[\"outputName\"],\n            })\n    return representations\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/export_tracking_points.html","title":"export_tracking_points","text":"<p>Extract tracking points from Mocha.</p>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/export_tracking_points.html#client.ayon_mocha.plugins.publish.export_tracking_points.ExportTrackingPoints","title":"<code>ExportTrackingPoints</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Export tracking points.</p> Source code in <code>client/ayon_mocha/plugins/publish/export_tracking_points.py</code> <pre><code>class ExportTrackingPoints(publish.Extractor):\n    \"\"\"Export tracking points.\"\"\"\n\n    label = \"Export Tracking Points\"\n    families: ClassVar[list[str]] = [\"trackpoints\"]\n    log: Logger\n\n    def process(self, instance: pyblish.api.Instance) -&gt; None:\n        \"\"\"Process the instance.\"\"\"\n        dir_path = Path(self.staging_dir(instance))\n        project: Project = instance.context.data[\"project\"]\n        layer: Layer = instance.data[\"layer\"]\n\n        process_info = ExporterProcessInfo(\n            mocha_python_path=instance.context.data[\"mocha_python_path\"],\n            mocha_exporter_path=instance.context.data[\"mocha_exporter_path\"],\n            current_project_path=instance.context.data[\"currentFile\"],\n            staging_dir=dir_path,\n            options=instance.data[\"exporter_options\"]\n        )\n\n        \"\"\"\n        representations = self.external_export_process(\n            instance.name,\n            instance.data[\"use_exporters\"],\n            layer,\n            process_info\n        )\n        \"\"\"\n        outputs = self.export(\n            instance.data[\"productName\"],\n            project,\n            instance.data[\"use_exporters\"],\n            layer,\n            process_info,\n        )\n\n        representations = self.process_outputs_to_representations(\n            outputs, instance)\n\n        instance.data.setdefault(\n            \"representations\", []).extend(representations)\n\n        self.log.debug(instance.data[\"representations\"])\n\n    def process_outputs_to_representations(\n            self, outputs: list[dict],\n            instance: pyblish.api.Instance) -&gt; list[dict]:\n        \"\"\"Process the output to representations.\n\n        This will process output from the exporters to representations.\n\n        Args:\n            outputs (list[dict]): list of outputs.\n            instance (pyblish.api.Instance): instance.\n\n        Returns:\n            list[dict]: list of representations.\n\n        Raises:\n            KnownPublishError: if the exporter produced multiple\n                sequences and single files.\n\n        \"\"\"\n        representations = []\n        staging_dir = Path(self.staging_dir(instance))\n\n        for output in outputs:\n            # if there are multiple files in one representation\n            # we need to check if it is sequence or not as current\n            # integration does not support multiple files that are not\n            # in sequences.\n            repre_name = self._exporter_name_to_representation_name(\n                output[\"name\"])\n\n            cols, rems = clique.assemble(output[\"files\"])\n            if rems and cols:\n                # there are both sequences and single files\n                if cols &gt; 1:\n                    # the extractor produced multiple sequences\n                    # and single files. This is not supported now\n                    # due to the complexity.\n                    msg = (\"The exporter produced multiple sequences \"\n                           \"and single files. This is not supported.\")\n                    raise KnownPublishError(msg)\n                output_files = cols[0]\n                for reminder in rems:\n                    self.add_to_resources(\n                        Path(self.staging_dir(instance)) / reminder, instance)\n                representations.append({\n                    \"name\": repre_name,\n                    \"ext\": output[\"ext\"],\n                    \"files\": output_files,\n                    \"stagingDir\": output[\"stagingDir\"],\n                    \"outputName\": output[\"outputName\"],\n                })\n            if rems and not cols:\n                if len(rems) &gt; 1:\n                    # if there are only non-sequence files\n                    for reminder in rems:\n                        self.add_to_resources(\n                            Path(self.staging_dir(instance)) / reminder, instance)  # noqa: E501\n                    manifest_file = self._create_manifest_file(\n                        staging_dir, rems, repre_name)\n                    representations.append({\n                        \"name\": repre_name,\n                        \"ext\": output[\"ext\"],\n                        \"files\": manifest_file,\n                        \"stagingDir\": output[\"stagingDir\"],\n                        \"outputName\": output[\"outputName\"],\n                    })\n                else:\n                    # if there is only one non-sequence file\n                    representations.append({\n                        \"name\": repre_name,\n                        \"ext\": output[\"ext\"],\n                        \"files\": rems[0],\n                        \"stagingDir\": output[\"stagingDir\"],\n                        \"outputName\": output[\"outputName\"],\n                    })\n            if cols and not rems:\n                # if there are only sequences\n                if len(cols) &gt; 1:\n                    # the extractor produced multiple sequences\n                    # and single files. This is not supported now\n                    # due to the complexity.\n                    msg = (\"The exporter produced multiple sequences \"\n                           \"and single files. This is not supported.\")\n                    raise KnownPublishError(msg)\n                representations.append({\n                    \"name\": repre_name,\n                    \"ext\": output[\"ext\"],\n                    \"files\": list(cols[0]),\n                    \"stagingDir\": output[\"stagingDir\"],\n                    \"outputName\": output[\"outputName\"],\n                })\n        return representations\n\n    @staticmethod\n    def _create_manifest_file(\n            staging_dir: Path, files: list[str], repre_name: str) -&gt; str:\n        \"\"\"Create a manifest file.\n\n        This will put all the files to a manifest file that\n        will be used as a representation. This is because the\n        current integration does not support multiple files\n        that are not in sequences.\n\n        Args:\n            staging_dir (Path): staging directory.\n            files (list[str]): list of files.\n            repre_name (str): representation name.\n\n        Returns:\n            str: manifest file name.\n\n        \"\"\"\n        file_name = f\"{repre_name}.manifest\"\n        manifest_file = staging_dir / file_name\n        with open(manifest_file, \"w\", encoding=\"utf-8\") as file:\n            file.writelines(files)\n        return file_name\n\n    def export(\n            self,\n            product_name: str,\n            project: Project,\n            exporters: list[ExporterInfo],\n            layer: Layer,\n            process_info: ExporterProcessInfo\n        ) -&gt; list[dict]:\n        \"\"\"Export the instance.\n\n        This is using in-process export but since the export\n        times are pretty fast, it's easier and probably\n        faster than using the external export.\n\n        Args:\n            product_name (str): used for naming the resulting\n                files.\n            project (Project): Mocha project.\n            exporters (list[ExporterInfo]): exporters to use.\n            layer (Layer): layer to export.\n            process_info (ExporterProcessInfo): process information.\n\n        Returns:\n            list[dict]: list of representations.\n\n        Raises:\n            KnownPublishError: if the export fails.\n\n        \"\"\"\n        views = [view_info.name for view_info in project.views]\n        views_to_export = list(\n            {\n                View(num)\n                for num, view_info in enumerate(project.views)\n                if view_info.name in views or view_info.abbr in views\n            }\n        )\n        output: list[dict] = []\n        for exporter_info in exporters:\n            exporter_name = exporter_info.label\n            if not exporter_name:\n                msg = (\"Cannot get exporter name \"\n                       f\"from {exporter_info.label} exporter.\")\n                raise KnownPublishError(msg)\n\n            \"\"\"\n            ext = self._get_extension(exporter_info)\n            if not ext:\n                msg = (\"Cannot get extension \"\n                       f\"from {exporter_info.label} exporter.\")\n                raise KnownPublishError(msg)\n            \"\"\"\n\n            options = process_info.options\n\n            exporter_short_hash = exporter_info.id[:8]\n\n            version = get_mocha_version() or \"2024\"\n\n            # exporters were rewritten in 2025. For older version\n            # we need to parse the file extension from the exporter\n            # label. We add it here so it is later on used from the\n            # resulted file name.\n            file_name = f\"{product_name}_{exporter_short_hash}\"\n            if int(version.split(\".\")[0]) &lt; MOCHA_2025:\n                ext = ExportTrackingPoints._get_extension(exporter_info)\n                if not ext:\n                    msg = (\"Cannot get extension \"\n                           f\"from {exporter_info.label} exporter.\")\n                    raise KnownPublishError(msg)\n                file_name += f\".{ExportTrackingPoints._get_extension(exporter_info)}\"  # noqa: E501\n\n            tracking_file_path = (\n                    process_info.staging_dir / file_name\n            )\n\n            result = exporter_info.exporter.do_export(\n                project,\n                layer,\n                tracking_file_path.as_posix(),\n                options.get(\"frame_time\", 0.0),\n                views_to_export[0],\n                {\n                    \"Invert\": options.get(\"invert\", False),\n                    \"RemoveLensDistortion\": options.get(\n                        \"remove_lens_distortion\", False)\n                }\n            )\n            self.log.debug(\n                \"Selected exporter: %s\", exporter_name)\n            self.log.debug(\n                \"Exporting to: %s\", tracking_file_path)\n            if not result:\n                msg = f\"Export failed for {exporter_name}.\"\n                raise KnownPublishError(msg)\n\n            output_files = []\n\n            ext = None\n            for k, v in result.items():\n                Path(k).write_bytes(v)\n                output_files.append(Path(k).name)\n                if ext is None:\n                    ext = Path(k).suffix[1:]\n\n            output.append({\n                \"name\": exporter_info.label,\n                \"ext\": ext,\n                \"files\": output_files,\n                \"stagingDir\": process_info.staging_dir.as_posix(),\n                \"outputName\": exporter_short_hash,\n            })\n\n        return output\n\n    def add_to_resources(\n            self, path: Path, instance: pyblish.api.Instance) -&gt; None:\n        \"\"\"Add the path to the resources.\"\"\"\n        self.log.debug(\"Adding to resources: %s\", path)\n\n        publish_dir_path = Path(instance.data[\"publishDir\"])\n        instance.data[\"transfers\"].append(\n            [path.as_posix(), (publish_dir_path / path.name).as_posix()])\n\n    def external_export_process(self,\n        instance_name: str,\n        exporters: list[ExporterInfo],\n        layer: Layer,\n        process_info: ExporterProcessInfo) -&gt; list[dict]:\n        \"\"\"Process the instance using external export.\n\n        This will prepare the arguments and run the external mocha exporter\n        script to export the tracking data.\n\n        Returns:\n            list[dict]: list of representations.\n\n        Raises:\n            KnownPublishError: if the export fails.\n\n        \"\"\"\n        invert: bool = process_info.options.get(\n            \"invert\", False)\n        remove_lens_distortion: bool = process_info.options.get(\n            \"remove_lens_distortion\", False)\n\n        args = [\n            process_info.mocha_python_path.as_posix(),\n            process_info.mocha_exporter_path.as_posix(),\n            \"--export-type=tracking\",\n            \"--project={}\".format(path_to_subprocess_arg(\n                process_info.current_project_path.as_posix())),\n        ]\n\n        if invert:\n            args += \"--invert\"\n\n        if remove_lens_distortion:\n            args += \"--remove-lens-distortion\"\n\n        self.log.debug(\n            \"Exporting data using %s exporters\",\n            len(exporters))\n\n        exporter_info: ExporterInfo\n        representations: list[dict] = []\n        for exporter_info in exporters:\n\n            exporter_name = exporter_info.label\n            if not exporter_name:\n                msg = (\"Cannot get exporter name \"\n                       f\"from {exporter_info.label} exporter.\")\n                raise KnownPublishError(msg)\n\n            ext = self._get_extension(exporter_info)\n            if not ext:\n                msg = (\"Cannot get extension \"\n                       f\"from {exporter_info.label} exporter.\")\n                raise KnownPublishError(msg)\n\n            args += [\n                f\"--exporter-name={exporter_info.label}\",\n                \"--file-path\", path_to_subprocess_arg(\n                    (process_info.staging_dir / f\"{instance_name}.{ext}\").as_posix()),  # noqa: E501\n                layer.name,\n                \"-v4\"\n            ]\n\n            self.log.info(\"Exporting: %s\", list2cmdline(args))\n            run_subprocess(list2cmdline(args), logger=self.log)\n\n            filename = f\"{instance_name}.{ext}\"\n            path = process_info.staging_dir / filename\n\n            if not path.exists():\n                msg = f\"Exported file {path} does not exist.\"\n                raise KnownPublishError(msg)\n\n            representations.append({\n                \"name\": self._exporter_name_to_representation_name(\n                    exporter_info.label),\n                \"ext\": ext,\n                \"files\": path.name,\n                \"stagingDir\": path.parent.as_posix(),\n            })\n\n        return representations\n\n    @staticmethod\n    def _get_extension(exporter_info: ExporterInfo) -&gt; Optional[str]:\n        \"\"\"Get the extension of the exporter.\n\n        This is used only if the exporter name contains the extension.\n        From Mocha 2025 the extension is not part of the exporter name\n        anymore.\n\n        Returns:\n            Optional[str]: extension of the exporter if detected.\n\n        \"\"\"\n        match = re.search(EXTENSION_PATTERN, exporter_info.label)\n        return match[\"ext\"] if match else None\n\n    @staticmethod\n    def _exporter_name_to_representation_name(\n            exporter_name: str) -&gt; str:\n        \"\"\"Convert the exporter name to representation name.\n\n        Args:\n            exporter_name (str): exporter name.\n\n        Returns:\n            str: exporter representation name.\n\n        \"\"\"\n        version = get_mocha_version() or \"2024\"\n        try:\n            mapping = EXPORTER_MAPPING[\"tracking\"][version]\n        except KeyError:\n            mapping = EXPORTER_MAPPING[\"tracking\"][\"2024.5\"]\n        return mapping.get(\n            exporter_name, exporter_name)\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/export_tracking_points.html#client.ayon_mocha.plugins.publish.export_tracking_points.ExportTrackingPoints.add_to_resources","title":"<code>add_to_resources(path, instance)</code>","text":"<p>Add the path to the resources.</p> Source code in <code>client/ayon_mocha/plugins/publish/export_tracking_points.py</code> <pre><code>def add_to_resources(\n        self, path: Path, instance: pyblish.api.Instance) -&gt; None:\n    \"\"\"Add the path to the resources.\"\"\"\n    self.log.debug(\"Adding to resources: %s\", path)\n\n    publish_dir_path = Path(instance.data[\"publishDir\"])\n    instance.data[\"transfers\"].append(\n        [path.as_posix(), (publish_dir_path / path.name).as_posix()])\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/export_tracking_points.html#client.ayon_mocha.plugins.publish.export_tracking_points.ExportTrackingPoints.export","title":"<code>export(product_name, project, exporters, layer, process_info)</code>","text":"<p>Export the instance.</p> <p>This is using in-process export but since the export times are pretty fast, it's easier and probably faster than using the external export.</p> <p>Parameters:</p> Name Type Description Default <code>product_name</code> <code>str</code> <p>used for naming the resulting files.</p> required <code>project</code> <code>Project</code> <p>Mocha project.</p> required <code>exporters</code> <code>list[ExporterInfo]</code> <p>exporters to use.</p> required <code>layer</code> <code>Layer</code> <p>layer to export.</p> required <code>process_info</code> <code>ExporterProcessInfo</code> <p>process information.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: list of representations.</p> <p>Raises:</p> Type Description <code>KnownPublishError</code> <p>if the export fails.</p> Source code in <code>client/ayon_mocha/plugins/publish/export_tracking_points.py</code> <pre><code>def export(\n        self,\n        product_name: str,\n        project: Project,\n        exporters: list[ExporterInfo],\n        layer: Layer,\n        process_info: ExporterProcessInfo\n    ) -&gt; list[dict]:\n    \"\"\"Export the instance.\n\n    This is using in-process export but since the export\n    times are pretty fast, it's easier and probably\n    faster than using the external export.\n\n    Args:\n        product_name (str): used for naming the resulting\n            files.\n        project (Project): Mocha project.\n        exporters (list[ExporterInfo]): exporters to use.\n        layer (Layer): layer to export.\n        process_info (ExporterProcessInfo): process information.\n\n    Returns:\n        list[dict]: list of representations.\n\n    Raises:\n        KnownPublishError: if the export fails.\n\n    \"\"\"\n    views = [view_info.name for view_info in project.views]\n    views_to_export = list(\n        {\n            View(num)\n            for num, view_info in enumerate(project.views)\n            if view_info.name in views or view_info.abbr in views\n        }\n    )\n    output: list[dict] = []\n    for exporter_info in exporters:\n        exporter_name = exporter_info.label\n        if not exporter_name:\n            msg = (\"Cannot get exporter name \"\n                   f\"from {exporter_info.label} exporter.\")\n            raise KnownPublishError(msg)\n\n        \"\"\"\n        ext = self._get_extension(exporter_info)\n        if not ext:\n            msg = (\"Cannot get extension \"\n                   f\"from {exporter_info.label} exporter.\")\n            raise KnownPublishError(msg)\n        \"\"\"\n\n        options = process_info.options\n\n        exporter_short_hash = exporter_info.id[:8]\n\n        version = get_mocha_version() or \"2024\"\n\n        # exporters were rewritten in 2025. For older version\n        # we need to parse the file extension from the exporter\n        # label. We add it here so it is later on used from the\n        # resulted file name.\n        file_name = f\"{product_name}_{exporter_short_hash}\"\n        if int(version.split(\".\")[0]) &lt; MOCHA_2025:\n            ext = ExportTrackingPoints._get_extension(exporter_info)\n            if not ext:\n                msg = (\"Cannot get extension \"\n                       f\"from {exporter_info.label} exporter.\")\n                raise KnownPublishError(msg)\n            file_name += f\".{ExportTrackingPoints._get_extension(exporter_info)}\"  # noqa: E501\n\n        tracking_file_path = (\n                process_info.staging_dir / file_name\n        )\n\n        result = exporter_info.exporter.do_export(\n            project,\n            layer,\n            tracking_file_path.as_posix(),\n            options.get(\"frame_time\", 0.0),\n            views_to_export[0],\n            {\n                \"Invert\": options.get(\"invert\", False),\n                \"RemoveLensDistortion\": options.get(\n                    \"remove_lens_distortion\", False)\n            }\n        )\n        self.log.debug(\n            \"Selected exporter: %s\", exporter_name)\n        self.log.debug(\n            \"Exporting to: %s\", tracking_file_path)\n        if not result:\n            msg = f\"Export failed for {exporter_name}.\"\n            raise KnownPublishError(msg)\n\n        output_files = []\n\n        ext = None\n        for k, v in result.items():\n            Path(k).write_bytes(v)\n            output_files.append(Path(k).name)\n            if ext is None:\n                ext = Path(k).suffix[1:]\n\n        output.append({\n            \"name\": exporter_info.label,\n            \"ext\": ext,\n            \"files\": output_files,\n            \"stagingDir\": process_info.staging_dir.as_posix(),\n            \"outputName\": exporter_short_hash,\n        })\n\n    return output\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/export_tracking_points.html#client.ayon_mocha.plugins.publish.export_tracking_points.ExportTrackingPoints.external_export_process","title":"<code>external_export_process(instance_name, exporters, layer, process_info)</code>","text":"<p>Process the instance using external export.</p> <p>This will prepare the arguments and run the external mocha exporter script to export the tracking data.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: list of representations.</p> <p>Raises:</p> Type Description <code>KnownPublishError</code> <p>if the export fails.</p> Source code in <code>client/ayon_mocha/plugins/publish/export_tracking_points.py</code> <pre><code>def external_export_process(self,\n    instance_name: str,\n    exporters: list[ExporterInfo],\n    layer: Layer,\n    process_info: ExporterProcessInfo) -&gt; list[dict]:\n    \"\"\"Process the instance using external export.\n\n    This will prepare the arguments and run the external mocha exporter\n    script to export the tracking data.\n\n    Returns:\n        list[dict]: list of representations.\n\n    Raises:\n        KnownPublishError: if the export fails.\n\n    \"\"\"\n    invert: bool = process_info.options.get(\n        \"invert\", False)\n    remove_lens_distortion: bool = process_info.options.get(\n        \"remove_lens_distortion\", False)\n\n    args = [\n        process_info.mocha_python_path.as_posix(),\n        process_info.mocha_exporter_path.as_posix(),\n        \"--export-type=tracking\",\n        \"--project={}\".format(path_to_subprocess_arg(\n            process_info.current_project_path.as_posix())),\n    ]\n\n    if invert:\n        args += \"--invert\"\n\n    if remove_lens_distortion:\n        args += \"--remove-lens-distortion\"\n\n    self.log.debug(\n        \"Exporting data using %s exporters\",\n        len(exporters))\n\n    exporter_info: ExporterInfo\n    representations: list[dict] = []\n    for exporter_info in exporters:\n\n        exporter_name = exporter_info.label\n        if not exporter_name:\n            msg = (\"Cannot get exporter name \"\n                   f\"from {exporter_info.label} exporter.\")\n            raise KnownPublishError(msg)\n\n        ext = self._get_extension(exporter_info)\n        if not ext:\n            msg = (\"Cannot get extension \"\n                   f\"from {exporter_info.label} exporter.\")\n            raise KnownPublishError(msg)\n\n        args += [\n            f\"--exporter-name={exporter_info.label}\",\n            \"--file-path\", path_to_subprocess_arg(\n                (process_info.staging_dir / f\"{instance_name}.{ext}\").as_posix()),  # noqa: E501\n            layer.name,\n            \"-v4\"\n        ]\n\n        self.log.info(\"Exporting: %s\", list2cmdline(args))\n        run_subprocess(list2cmdline(args), logger=self.log)\n\n        filename = f\"{instance_name}.{ext}\"\n        path = process_info.staging_dir / filename\n\n        if not path.exists():\n            msg = f\"Exported file {path} does not exist.\"\n            raise KnownPublishError(msg)\n\n        representations.append({\n            \"name\": self._exporter_name_to_representation_name(\n                exporter_info.label),\n            \"ext\": ext,\n            \"files\": path.name,\n            \"stagingDir\": path.parent.as_posix(),\n        })\n\n    return representations\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/export_tracking_points.html#client.ayon_mocha.plugins.publish.export_tracking_points.ExportTrackingPoints.process","title":"<code>process(instance)</code>","text":"<p>Process the instance.</p> Source code in <code>client/ayon_mocha/plugins/publish/export_tracking_points.py</code> <pre><code>def process(self, instance: pyblish.api.Instance) -&gt; None:\n    \"\"\"Process the instance.\"\"\"\n    dir_path = Path(self.staging_dir(instance))\n    project: Project = instance.context.data[\"project\"]\n    layer: Layer = instance.data[\"layer\"]\n\n    process_info = ExporterProcessInfo(\n        mocha_python_path=instance.context.data[\"mocha_python_path\"],\n        mocha_exporter_path=instance.context.data[\"mocha_exporter_path\"],\n        current_project_path=instance.context.data[\"currentFile\"],\n        staging_dir=dir_path,\n        options=instance.data[\"exporter_options\"]\n    )\n\n    \"\"\"\n    representations = self.external_export_process(\n        instance.name,\n        instance.data[\"use_exporters\"],\n        layer,\n        process_info\n    )\n    \"\"\"\n    outputs = self.export(\n        instance.data[\"productName\"],\n        project,\n        instance.data[\"use_exporters\"],\n        layer,\n        process_info,\n    )\n\n    representations = self.process_outputs_to_representations(\n        outputs, instance)\n\n    instance.data.setdefault(\n        \"representations\", []).extend(representations)\n\n    self.log.debug(instance.data[\"representations\"])\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/export_tracking_points.html#client.ayon_mocha.plugins.publish.export_tracking_points.ExportTrackingPoints.process_outputs_to_representations","title":"<code>process_outputs_to_representations(outputs, instance)</code>","text":"<p>Process the output to representations.</p> <p>This will process output from the exporters to representations.</p> <p>Parameters:</p> Name Type Description Default <code>outputs</code> <code>list[dict]</code> <p>list of outputs.</p> required <code>instance</code> <code>Instance</code> <p>instance.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: list of representations.</p> <p>Raises:</p> Type Description <code>KnownPublishError</code> <p>if the exporter produced multiple sequences and single files.</p> Source code in <code>client/ayon_mocha/plugins/publish/export_tracking_points.py</code> <pre><code>def process_outputs_to_representations(\n        self, outputs: list[dict],\n        instance: pyblish.api.Instance) -&gt; list[dict]:\n    \"\"\"Process the output to representations.\n\n    This will process output from the exporters to representations.\n\n    Args:\n        outputs (list[dict]): list of outputs.\n        instance (pyblish.api.Instance): instance.\n\n    Returns:\n        list[dict]: list of representations.\n\n    Raises:\n        KnownPublishError: if the exporter produced multiple\n            sequences and single files.\n\n    \"\"\"\n    representations = []\n    staging_dir = Path(self.staging_dir(instance))\n\n    for output in outputs:\n        # if there are multiple files in one representation\n        # we need to check if it is sequence or not as current\n        # integration does not support multiple files that are not\n        # in sequences.\n        repre_name = self._exporter_name_to_representation_name(\n            output[\"name\"])\n\n        cols, rems = clique.assemble(output[\"files\"])\n        if rems and cols:\n            # there are both sequences and single files\n            if cols &gt; 1:\n                # the extractor produced multiple sequences\n                # and single files. This is not supported now\n                # due to the complexity.\n                msg = (\"The exporter produced multiple sequences \"\n                       \"and single files. This is not supported.\")\n                raise KnownPublishError(msg)\n            output_files = cols[0]\n            for reminder in rems:\n                self.add_to_resources(\n                    Path(self.staging_dir(instance)) / reminder, instance)\n            representations.append({\n                \"name\": repre_name,\n                \"ext\": output[\"ext\"],\n                \"files\": output_files,\n                \"stagingDir\": output[\"stagingDir\"],\n                \"outputName\": output[\"outputName\"],\n            })\n        if rems and not cols:\n            if len(rems) &gt; 1:\n                # if there are only non-sequence files\n                for reminder in rems:\n                    self.add_to_resources(\n                        Path(self.staging_dir(instance)) / reminder, instance)  # noqa: E501\n                manifest_file = self._create_manifest_file(\n                    staging_dir, rems, repre_name)\n                representations.append({\n                    \"name\": repre_name,\n                    \"ext\": output[\"ext\"],\n                    \"files\": manifest_file,\n                    \"stagingDir\": output[\"stagingDir\"],\n                    \"outputName\": output[\"outputName\"],\n                })\n            else:\n                # if there is only one non-sequence file\n                representations.append({\n                    \"name\": repre_name,\n                    \"ext\": output[\"ext\"],\n                    \"files\": rems[0],\n                    \"stagingDir\": output[\"stagingDir\"],\n                    \"outputName\": output[\"outputName\"],\n                })\n        if cols and not rems:\n            # if there are only sequences\n            if len(cols) &gt; 1:\n                # the extractor produced multiple sequences\n                # and single files. This is not supported now\n                # due to the complexity.\n                msg = (\"The exporter produced multiple sequences \"\n                       \"and single files. This is not supported.\")\n                raise KnownPublishError(msg)\n            representations.append({\n                \"name\": repre_name,\n                \"ext\": output[\"ext\"],\n                \"files\": list(cols[0]),\n                \"stagingDir\": output[\"stagingDir\"],\n                \"outputName\": output[\"outputName\"],\n            })\n    return representations\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/validate_layers_and_exporters.html","title":"validate_layers_and_exporters","text":"<p>Validate layers and exportes.</p>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/validate_layers_and_exporters.html#client.ayon_mocha.plugins.publish.validate_layers_and_exporters.ValidateLayersAndExporters","title":"<code>ValidateLayersAndExporters</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validate layers and exporters set.</p> Source code in <code>client/ayon_mocha/plugins/publish/validate_layers_and_exporters.py</code> <pre><code>class ValidateLayersAndExporters(pyblish.api.InstancePlugin):\n    \"\"\"Validate layers and exporters set.\"\"\"\n\n    order = pyblish.api.Validator.order + 0.1\n    label = \"Validate Exporters and Layers\"\n    hosts: ClassVar[list[str]] = [\"mochapro\"]\n    families: ClassVar[list[str]] = [\"matteshapes\", \"trackpoints\"]\n    log: Logger\n\n    def process(self, instance: pyblish.api.Instance) -&gt; None:\n        \"\"\"Process all the trackpoints.\n\n        Raises:\n            PublishValidationError: If no layers or exporters are set.\n\n        \"\"\"\n        self.log.debug(\"Validating layers and exporters\")\n        if not instance.data.get(\"layer\"):\n            msg = (\n                f\"No layers set for instance {instance.name}\"\n            )\n            raise PublishValidationError(\n                msg, description=self._missing_layer_description())\n\n        if not instance.data.get(\"use_exporters\"):\n            msg = (\n                f\"No exporters set for instance {instance.name}\"\n            )\n            raise PublishValidationError(\n                msg, description=self._missing_exporter())\n\n    @classmethod\n    def _missing_layer_description(cls) -&gt; str:\n        \"\"\"Return the description for missing layer.\"\"\"\n        return inspect.cleandoc(\n            \"\"\"\n            ### Issue\n\n            The instance doesn't have layers set. Please select the layer\n            in the publisher,or set the layer mode to \"All layers\".\n            \"\"\"\n        )\n\n    @classmethod\n    def _missing_exporter(cls) -&gt; str:\n        \"\"\"Return the description for missing layer.\"\"\"\n        return inspect.cleandoc(\n            \"\"\"\n            ### Issue\n\n            You need to select at least one exporter.\n            \"\"\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/validate_layers_and_exporters.html#client.ayon_mocha.plugins.publish.validate_layers_and_exporters.ValidateLayersAndExporters.process","title":"<code>process(instance)</code>","text":"<p>Process all the trackpoints.</p> <p>Raises:</p> Type Description <code>PublishValidationError</code> <p>If no layers or exporters are set.</p> Source code in <code>client/ayon_mocha/plugins/publish/validate_layers_and_exporters.py</code> <pre><code>def process(self, instance: pyblish.api.Instance) -&gt; None:\n    \"\"\"Process all the trackpoints.\n\n    Raises:\n        PublishValidationError: If no layers or exporters are set.\n\n    \"\"\"\n    self.log.debug(\"Validating layers and exporters\")\n    if not instance.data.get(\"layer\"):\n        msg = (\n            f\"No layers set for instance {instance.name}\"\n        )\n        raise PublishValidationError(\n            msg, description=self._missing_layer_description())\n\n    if not instance.data.get(\"use_exporters\"):\n        msg = (\n            f\"No exporters set for instance {instance.name}\"\n        )\n        raise PublishValidationError(\n            msg, description=self._missing_exporter())\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/validate_trackpoints_layers.html","title":"validate_trackpoints_layers","text":"<p>Validate layer names in trackpoints.</p>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/validate_trackpoints_layers.html#client.ayon_mocha.plugins.publish.validate_trackpoints_layers.ValidateTrackpointLayers","title":"<code>ValidateTrackpointLayers</code>","text":"<p>               Bases: <code>Validator</code></p> <p>Validate layer names in trackpoints.</p> Source code in <code>client/ayon_mocha/plugins/publish/validate_trackpoints_layers.py</code> <pre><code>class ValidateTrackpointLayers(pyblish.api.Validator):\n    \"\"\"Validate layer names in trackpoints.\"\"\"\n\n    order = pyblish.api.Validator.order + 0.1\n    label = \"Validate Trackpoint Layers\"\n    hosts: ClassVar[list[str]] = [\"mochapro\"]\n    families: ClassVar[list[str]] = [\"trackpoints\"]\n    log: Logger\n\n    def process(self, instance: pyblish.api.Instance) -&gt; None:\n        \"\"\"Process all the trackpoints.\n\n        Raises:\n            PublishValidationError: If the layer index is not found.\n\n        \"\"\"\n        if not instance.data.get(\"layer\"):\n            msg = (\n                f\"Specified layer index ({instance.data['layer']} \"\n                \"does not exist in the project\"\n            )\n            raise PublishValidationError(\n                msg, description=self._missing_layer_description())\n\n        if len(instance.data[\"use_exporters\"]) == 0:\n            msg = (\n                \"Multiple exporters are not supported for trackpoints. \"\n                \"Please use only one exporter\"\n            )\n            raise PublishValidationError(\n                msg, description=self._missing_exporter())\n\n    @classmethod\n    def _missing_layer_description(cls) -&gt; str:\n        \"\"\"Return the description for missing layer.\"\"\"\n        return inspect.cleandoc(\n            \"\"\"\n            ### Issue\n\n            The instance is missing the layer attribute. Select the layer\n            in the publisher.\n            \"\"\"\n        )\n\n    @classmethod\n    def _missing_exporter(cls) -&gt; str:\n        \"\"\"Return the description for missing layer.\"\"\"\n        return inspect.cleandoc(\n            \"\"\"\n            ### Issue\n\n            You need to select at least one exporter on the instance.\n            \"\"\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/plugins/publish/validate_trackpoints_layers.html#client.ayon_mocha.plugins.publish.validate_trackpoints_layers.ValidateTrackpointLayers.process","title":"<code>process(instance)</code>","text":"<p>Process all the trackpoints.</p> <p>Raises:</p> Type Description <code>PublishValidationError</code> <p>If the layer index is not found.</p> Source code in <code>client/ayon_mocha/plugins/publish/validate_trackpoints_layers.py</code> <pre><code>def process(self, instance: pyblish.api.Instance) -&gt; None:\n    \"\"\"Process all the trackpoints.\n\n    Raises:\n        PublishValidationError: If the layer index is not found.\n\n    \"\"\"\n    if not instance.data.get(\"layer\"):\n        msg = (\n            f\"Specified layer index ({instance.data['layer']} \"\n            \"does not exist in the project\"\n        )\n        raise PublishValidationError(\n            msg, description=self._missing_layer_description())\n\n    if len(instance.data[\"use_exporters\"]) == 0:\n        msg = (\n            \"Multiple exporters are not supported for trackpoints. \"\n            \"Please use only one exporter\"\n        )\n        raise PublishValidationError(\n            msg, description=self._missing_exporter())\n</code></pre>"},{"location":"autoapi/client/ayon_mocha/resources/index.html","title":"resources","text":""},{"location":"autoapi/client/ayon_mocha/startup/index.html","title":"startup","text":""},{"location":"autoapi/client/ayon_mocha/startup/init.html","title":"init","text":"<p>Mocha Pro startup script.</p> <p>This script is used for AYON related functionality.</p>"},{"location":"autoapi/server/index.html","title":"server","text":"<p>Server addon implementation.</p>"},{"location":"autoapi/server/index.html#server.MochaAddon","title":"<code>MochaAddon</code>","text":"<p>               Bases: <code>BaseServerAddon</code></p> <p>BorisFX Mocha Pro addon for AYON settings.</p> Source code in <code>server/__init__.py</code> <pre><code>class MochaAddon(BaseServerAddon):\n    \"\"\"BorisFX Mocha Pro addon for AYON settings.\"\"\"\n    settings_model: Type[MochaProSettings] = MochaProSettings\n\n    async def get_default_settings(self) -&gt; dict:\n        \"\"\"Return default settings.\"\"\"\n        settings_model_cls = self.get_settings_model()\n        return settings_model_cls(**DEFAULT_VALUES)\n</code></pre>"},{"location":"autoapi/server/index.html#server.MochaAddon.get_default_settings","title":"<code>get_default_settings()</code>  <code>async</code>","text":"<p>Return default settings.</p> Source code in <code>server/__init__.py</code> <pre><code>async def get_default_settings(self) -&gt; dict:\n    \"\"\"Return default settings.\"\"\"\n    settings_model_cls = self.get_settings_model()\n    return settings_model_cls(**DEFAULT_VALUES)\n</code></pre>"},{"location":"autoapi/server/settings/index.html","title":"settings","text":"<p>Settings module for the server package.</p>"},{"location":"autoapi/server/settings/index.html#server.settings.MochaProSettings","title":"<code>MochaProSettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Settings for the Mocha Pro Addon.</p> Source code in <code>server/settings/main.py</code> <pre><code>class MochaProSettings(BaseSettingsModel):\n    \"\"\"Settings for the Mocha Pro Addon.\"\"\"\n    create: MochaProCreatorPlugins = SettingsField(\n        default_factory=MochaProCreatorPlugins,\n        title=\"Creator Plugins\")\n</code></pre>"},{"location":"autoapi/server/settings/creator_plugins.html","title":"creator_plugins","text":"<p>Creator settings for Mocha Pro.</p>"},{"location":"autoapi/server/settings/creator_plugins.html#server.settings.creator_plugins.CreateShapeDataModel","title":"<code>CreateShapeDataModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Settings for creating shapes.</p> Source code in <code>server/settings/creator_plugins.py</code> <pre><code>class CreateShapeDataModel(BaseSettingsModel):\n    \"\"\"Settings for creating shapes.\"\"\"\n    enabled: bool = SettingsField(\n        default=True, title=\"Enabled\")\n    mocha_2024_5: Mocha2024ShapeModel = SettingsField(\n        default_factory=Mocha2024ShapeModel,\n        title=\"Mocha Pro 2024\")\n    mocha_2025: Mocha2025ShapeModel = SettingsField(\n        default_factory=Mocha2025ShapeModel,\n        title=\"Mocha Pro 2025\")\n</code></pre>"},{"location":"autoapi/server/settings/creator_plugins.html#server.settings.creator_plugins.CreateTrackingPointsModel","title":"<code>CreateTrackingPointsModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Settings for creating tracking points.</p> Source code in <code>server/settings/creator_plugins.py</code> <pre><code>class CreateTrackingPointsModel(BaseSettingsModel):\n    \"\"\"Settings for creating tracking points.\"\"\"\n    enabled: bool = SettingsField(\n        default=True, title=\"Enabled\")\n    mocha_2024_5: Mocha2024TrackingModel = SettingsField(\n        default_factory=Mocha2024TrackingModel,\n        title=\"Mocha Pro 2024\")\n    mocha_2025: Mocha2025TrackingModel = SettingsField(\n        default_factory=Mocha2025TrackingModel,\n        title=\"Mocha Pro 2025\")\n</code></pre>"},{"location":"autoapi/server/settings/creator_plugins.html#server.settings.creator_plugins.Mocha2024ShapeModel","title":"<code>Mocha2024ShapeModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Mocha Pro 2024 shape settings.</p> Source code in <code>server/settings/creator_plugins.py</code> <pre><code>class Mocha2024ShapeModel(BaseSettingsModel):\n    \"\"\"Mocha Pro 2024 shape settings.\"\"\"\n    default_exporters: list[str] = SettingsField(\n        default_factory=list, title=\"Default exporters\",\n        enum_resolver=shapes_exporter_enum_2024_5)\n</code></pre>"},{"location":"autoapi/server/settings/creator_plugins.html#server.settings.creator_plugins.Mocha2024TrackingModel","title":"<code>Mocha2024TrackingModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Mocha Pro 2024 tracking settings.</p> Source code in <code>server/settings/creator_plugins.py</code> <pre><code>class Mocha2024TrackingModel(BaseSettingsModel):\n    \"\"\"Mocha Pro 2024 tracking settings.\"\"\"\n    default_exporters: list[str] = SettingsField(\n        default_factory=list, title=\"Default exporters\",\n        enum_resolver=tracking_exporter_enum_2024_5)\n</code></pre>"},{"location":"autoapi/server/settings/creator_plugins.html#server.settings.creator_plugins.Mocha2025ShapeModel","title":"<code>Mocha2025ShapeModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Mocha Pro 2025 shape settings.</p> Source code in <code>server/settings/creator_plugins.py</code> <pre><code>class Mocha2025ShapeModel(BaseSettingsModel):\n    \"\"\"Mocha Pro 2025 shape settings.\"\"\"\n    default_exporters: list[str] = SettingsField(\n        default_factory=list, title=\"Default exporters\",\n        enum_resolver=shapes_exporter_enum_2025)\n</code></pre>"},{"location":"autoapi/server/settings/creator_plugins.html#server.settings.creator_plugins.Mocha2025TrackingModel","title":"<code>Mocha2025TrackingModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Mocha Pro 2025 tracking settings.</p> Source code in <code>server/settings/creator_plugins.py</code> <pre><code>class Mocha2025TrackingModel(BaseSettingsModel):\n    \"\"\"Mocha Pro 2025 tracking settings.\"\"\"\n    default_exporters: list[str] = SettingsField(\n        default_factory=list, title=\"Default exporters\",\n        enum_resolver=tracking_exporter_enum_2025)\n</code></pre>"},{"location":"autoapi/server/settings/creator_plugins.html#server.settings.creator_plugins.MochaProCreatorPlugins","title":"<code>MochaProCreatorPlugins</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Mocha Pro creator plugins settings.</p> Source code in <code>server/settings/creator_plugins.py</code> <pre><code>class MochaProCreatorPlugins(BaseSettingsModel):\n    \"\"\"Mocha Pro creator plugins settings.\"\"\"\n    CreateTrackingPoints: CreateTrackingPointsModel = SettingsField(\n        default_factory=CreateTrackingPointsModel,\n        title=\"Create Tracking Points\")\n    CreateShapeData: CreateShapeDataModel = SettingsField(\n        default_factory=CreateShapeDataModel,\n        title=\"Create Shapes\")\n</code></pre>"},{"location":"autoapi/server/settings/creator_plugins.html#server.settings.creator_plugins.shapes_exporter_enum_2024_5","title":"<code>shapes_exporter_enum_2024_5()</code>","text":"<p>Return enum for shape exporters.</p> Source code in <code>server/settings/creator_plugins.py</code> <pre><code>def shapes_exporter_enum_2024_5() -&gt; list[dict[str, str]]:\n    \"\"\"Return enum for shape exporters.\"\"\"\n    return [\n        {\n            \"label\": \"Adobe After Effects Mask Data (*.shape4ae)\",\n            \"value\": \"AfxMask\"},\n        {\n            \"label\": \"Adobe Premiere shape data (*.xml)\",\n            \"value\":  \"PremiereShape\"},\n        {\n            \"label\": \"BlackMagic Fusion 19+ MultiPoly shapes (*.comp)\",\n            \"value\":  \"FusionMultiPoly\"},\n        {\n            \"label\": \"BlackMagic Fusion shapes (*.comp)\",\n            \"value\":  \"FusionShapes\"},\n        {\n            \"label\": \"Combustion GMask Script (*.gmask)\",\n            \"value\":  \"CombustionGMask\"},\n        {\n            \"label\": \"Flame GMask Script (*.gmask)\",\n            \"value\":  \"FlameGMask\"},\n        {\n            \"label\": \"Flame Tracer [Basic] (*.mask)\",\n            \"value\":  \"FlameTracerBasic\"},\n        {\n            \"label\": \"Flame Tracer [Shape + Axis] (*.mask)\",\n            \"value\":  \"FlameTracerShapeAxis\"},\n        {\n            \"label\": \"HitFilm [Transform &amp; Shape] (*.hfcs)\",\n            \"value\":  \"HitFilmTransformShape\"},\n        {\n            \"label\": \"Mocha shape data for Final Cut (*.xml)\",\n            \"value\":  \"MochaShapeFinalCut\"},\n        {\n            \"label\": \"MochaBlend shape data (*.txt)\",\n            \"value\": \"MochaBlend\"},\n        {\n            \"label\": \"Nuke Roto [Basic] (*.nk)\",\n            \"value\":  \"NuRotoBasic\"},\n        {\n            \"label\": \"Nuke RotoPaint [Basic] (*.nk)\",\n            \"value\":  \"NukeRotoPaintBasic\"},\n        {\n            \"label\": \"Nuke SplineWarp (*.nk)\",\n            \"value\": \"NukeSplineWarp\"},\n        {\n            \"label\": \"Nuke v6.2+ Roto [Transform &amp; Shape] (*.nk)\",\n            \"value\":  \"NukeRotoTransformShape\"},\n        {\n            \"label\": \"Nuke v6.2+ RotoPaint [Transform &amp; Shape] (*.nk)\",\n            \"value\":  \"NukeRotoPaint\"},\n        {\n            \"label\": \"Shake Rotoshape (*.ssf)\",\n            \"value\":  \"ShapeRotoshape\"},\n        {\n            \"label\": \"Silhouette shapes (*.fxs)\",\n            \"value\":  \"SilhouetteShapes\"},\n    ]\n</code></pre>"},{"location":"autoapi/server/settings/creator_plugins.html#server.settings.creator_plugins.shapes_exporter_enum_2025","title":"<code>shapes_exporter_enum_2025()</code>","text":"<p>Return enum for shape exporters form Mocha Pro 2025.</p> Source code in <code>server/settings/creator_plugins.py</code> <pre><code>def shapes_exporter_enum_2025() -&gt; list[dict[str, str]]:\n    \"\"\"Return enum for shape exporters form Mocha Pro 2025.\"\"\"\n    return [\n        {\n            \"label\": \"After Effects Mask Data\",\n            \"value\": \"AfxMask\",\n        },\n        {\n            \"label\": \"Combustion GMask Script\",\n            \"value\": \"CombustionGMask\",\n        },\n        {\n            \"label\": \"Final Cut Mocha Shape Data - 7.0.0\",\n            \"value\": \"FinalCutMochaShape\",\n        },\n        {\n            \"label\": \"Flame Gmask Script\",\n            \"value\": \"FlameGMask\",\n        },\n        {\n            \"label\": \"Flame Tracer [Basic]\",\n            \"value\": \"FlameTracerBasic\",\n        },\n        {\n            \"label\": \"Flame Tracer [Shape &amp; Axis]\",\n            \"value\": \"FlameTracerShapeAxis\",\n        },\n        {\n            \"label\": \"Fusion MultiPoly Shape Data\",\n            \"value\": \"FusionMultiPoly\",\n        },\n        {\n            \"label\": \"Fusion Poly Shape Data\",\n            \"value\": \"FusionShapes\",\n        },\n        {\n            \"label\": \"HitFilm Mask Data\",\n            \"value\": \"HitFilmTransformShape\",\n        },\n        {\n            \"label\": \"MochaBlend Shape Data\",\n            \"value\": \"MochaBlend\",\n        },\n        {\n            \"label\": \"Nuke Roto [Basic]\",\n            \"value\": \"NukeRotoBasic\",\n        },\n        {\n            \"label\": \"Nuke Roto [Transform &amp; Shape]-6.2+\",\n            \"value\": \"NukeRotoTransformShape\",\n        },\n        {\n            \"label\": \"Nuke RotoPaint [Basic]\",\n            \"value\": \"NukeRotoPaintBasic\",\n        },\n        {\n            \"label\": \"Nuke RotoPaint [Transform &amp; Shape] - 6.2+\",\n            \"value\": \"NukeRotoPaint\",\n        },\n        {\n            \"label\": \"Nuke SplineWarp\",\n            \"value\": \"NukeSplineWarp\",\n        },\n        {\n            \"label\": \"Premiere Shape Data\",\n            \"value\": \"PremiereShape\",\n        },\n        {\n            \"label\": \"Shake RotoShape\",\n            \"value\": \"ShapeRotoshape\",\n        },\n        {\n            \"label\": \"Silhouette Shape Data\",\n            \"value\": \"SilhouetteShapes\",\n        },\n    ]\n</code></pre>"},{"location":"autoapi/server/settings/creator_plugins.html#server.settings.creator_plugins.tracking_exporter_enum_2024_5","title":"<code>tracking_exporter_enum_2024_5()</code>","text":"<p>Return enum for tracking exporters.</p> Source code in <code>server/settings/creator_plugins.py</code> <pre><code>def tracking_exporter_enum_2024_5() -&gt; list[dict[str, str]]:\n    \"\"\"Return enum for tracking exporters.\"\"\"\n    return [\n        {\n            \"label\": \"2D SynthEyes Tracker Data (*.sni)\",\n            \"value\": \"SynthEyes2DTracker\"},\n        {\n            \"label\": \"After Effects CC Power Pin (*.txt)\",\n            \"value\": \"AfxCCPowerPin\"},\n        {\n            \"label\": (\"After Effects CS3 Corner Pin [supports motion blur, \"\n                      \"CS3 and older] (*.txt)\"),\n            \"value\": \"AfxCS3CornerPin\"},\n        {\n            \"label\": (\"After Effects Corner Pin [corner pin only, \"\n                      \"supports RG Warp and mochaImport] (*.txt)\"),\n            \"value\": \"AfxCornerPin\"},\n        {\n            \"label\": (\"After Effects Corner Pin \"\n                      \"[supports motion blur] (*.txt)\"),\n            \"value\": \"AfxCornerPinMotionBlur\"},\n        {\n            \"label\": (\"After Effects Transform Data [position, \"\n                      \"scale and rotation] (*.txt)\"),\n            \"value\": \"AfxTransformData\"},\n        {\n            \"label\": \"Alembic Mesh Data (*.abc)\",\n            \"value\": \"AlembicMeshData\"},\n        {\n            \"label\": \"Alembic Vertex Transform Data (*.abc)\",\n            \"value\": \"AlembicVertexTransform\"},\n        {\n            \"label\": \"Assimilate SCRATCH Corner Pin (*.txt)\",\n            \"value\": \"AssimilateSCRATCHCornerPin\"},\n        {\n            \"label\": \"Autodesk Flame Axis (*.mask)\",\n            \"value\": \"FlameAxis\"},\n        {\n            \"label\": \"Autodesk IFFFSE Point Tracker Data (*.ascii)\",\n            \"value\": \"IFFFSEPointTracker\"},\n        {\n            \"label\": (\"Autodesk IFFFSE Point Tracker Data \"\n                      \"(Flame 2014) (*.ascii)\"),\n            \"value\": \"Flame2014PointTracker\"},\n        {\n            \"label\": \"Autodesk IFFFSE Stabilizer Data (*.stabilizer)\",\n            \"value\": \"IFFFSEStabilizer\"},\n        {\n            \"label\": (\"Autodesk IFFFSE Stabilizer Data (Flame 2014) \"\n                      \"(*.stabilizer)\"),\n            \"value\": \"Flame2014Stabilize\"},\n        {\n            \"label\": \"Avid DS Tracking Data (*.fraw)\",\n            \"value\": \"AvidDSTrackingData\"},\n        {\n            \"label\": \"Blackmagic Fusion COMP Data (*.comp)\",\n            \"value\": \"FusionCompData\"},\n        {\n            \"label\": \"Boris FX Center Point (Continuum 11 and older) (*.txt)\",\n            \"value\": \"BorisFXCenterPoint\"},\n        {\n            \"label\": \"Boris FX Corner Pin (Continuum 11 and older) (*.txt)\",\n            \"value\": \"BorisFXCornerPin\"},\n        {\n            \"label\": (\"Final Cut Basic Motion \"\n                      \"[translate, rotate, scale] (*.xml)\"),\n            \"value\": \"FinalCutBasicMotion\"},\n        {\n            \"label\": \"Final Cut Distort [corner pin] (*.xml)\",\n            \"value\": \"FinalCutDistort\"},\n        {\n            \"label\": \"Flowbox corner pin (*.flowbox)\",\n            \"value\": \"FlowboxCornerPin\"},\n        {\n            \"label\": \"HitFilm Corner Pin [supports motion blur] (*.hfcs)\",\n            \"value\": \"HitFilmCornerPin\"},\n        {\n            \"label\": (\"HitFilm Transform Data \"\n                      \"[position, scale and rotation] (*.hfcs)\"),\n            \"value\": \"HitFilmTransformData\"},\n        {\n            \"label\": \"Mistika Point Tracker File (*.trk)\",\n            \"value\": \"MistikaPointTracker\"},\n        {\n            \"label\": \"MochaBlend tracking data (*.txt)\",\n            \"value\": \"MochaBlend\"},\n        {\n            \"label\": \"Motion basic transform (*.motn)\",\n            \"value\": \"MotionBasicTransform\"},\n        {\n            \"label\": \"Motion corner pin (*.motn)\",\n            \"value\": \"MotionCornerPin\"},\n        {\n            \"label\": \"Nuke 7 Tracker (*.nk)\",\n            \"value\": \"Nuke7Tracker\"},\n        {\n            \"label\": \"Nuke Ascii (*.txt)\",\n            \"value\": \"NukeAscii\"},\n        {\n            \"label\": \"Nuke Corner Pin (*.nk)\",\n            \"value\": \"NukeCornerPin\"},\n        {\n            \"label\": \"Nuke Mesh Tracker (*.nk)\",\n            \"value\": \"NukeMeshTracker\"},\n        {\n            \"label\": \"Quantel Corner Pin Data (*.xml)\",\n            \"value\": \"QuantelCornerPin\"},\n        {\n            \"label\": \"Shake Script (*.shk)\",\n            \"value\": \"ShakeScript\"},\n        {\n            \"label\": \"Silhouette corner pin (*.txt)\",\n            \"value\": \"SilhouetteCornerPin\"},\n    ]\n</code></pre>"},{"location":"autoapi/server/settings/creator_plugins.html#server.settings.creator_plugins.tracking_exporter_enum_2025","title":"<code>tracking_exporter_enum_2025()</code>","text":"<p>Return enum for tracking exporters.</p> Source code in <code>server/settings/creator_plugins.py</code> <pre><code>def tracking_exporter_enum_2025() -&gt; list[dict[str, str]]:\n    \"\"\"Return enum for tracking exporters.\"\"\"\n    return [\n        {\n            \"label\": \"After Effects CC Power Pin\",\n            \"value\": \"AfxCCPowerPin\",\n        },\n        {\n            \"label\": \"After Effects CS3 Corner Pin\",\n            \"value\": \"AfxCS3CornerPin\",\n        },\n        {\n            \"label\": \"After Effects Corner Pin\",\n            \"value\": \"AfxCornerPin\",\n        },\n        {\n            \"label\": \"After Effects Corner Pin with Motion Blur\",\n            \"value\": \"AfxCornerPinMotionBlur\",\n        },\n        {\n            \"label\": \"After Effects Transform Data\",\n            \"value\": \"AfxTransformData\",\n        },\n        {\n            \"label\": \"Alembic 2D Mesh Data\",\n            \"value\": \"AlembicMeshData\",\n        },\n        {\n            \"label\": \"Alembic 2D Vertex Transform\",\n            \"value\": \"AlembicVertexTransform\",\n        },\n        {\n            \"label\": \"Avid DS Tracking Data\",\n            \"value\": \"AvidDSTrackingData\",\n        },\n        {\n            \"label\": \"Continuum Center Point - 11.0.0\",\n            \"value\": \"BorisFXCenterPoint\",\n        },\n        {\n            \"label\": \"Continuum Corner Pin - 11.0.0\",\n            \"value\": \"BorisFXCornerPin\",\n        },\n        {\n            \"label\": \"Final Cut Basic Motion - 7.0.0\",\n            \"value\": \"FinalCutBasicMotion\",\n        },\n        {\n            \"label\": \"Final Cut Distort - 7.0.0\",\n            \"value\": \"FinalCutDistort\",\n        },\n        {\n            \"label\": \"Flame Axis\",\n            \"value\": \"FlameAxis\",\n        },\n        {\n            \"label\": \"Flame Point Stabilizer Data - 2014.0.0\",\n            \"value\": \"Flame2014Stabilize\",\n        },\n        {\n            \"label\": \"Flame Point Tracker Data\",\n            \"value\": \"IFFFSEPointTracker\",\n        },\n        {\n            \"label\": \"Flame Point Tracker Data - 2014.0.0\",\n            \"value\": \"Flame2014PointTracker\",\n        },\n        {\n            \"label\": \"Flame Stabilizer Data\",\n            \"value\": \"IFFFSEStabilizer\",\n        },\n        {\n            \"label\": \"Flowbox Corner Pin\",\n            \"value\": \"FlowboxCornerPin\",\n        },\n        {\n            \"label\": \"Fusion Tracker Data\",\n            \"value\": \"FusionCompData\",\n        },\n        {\n            \"label\": \"HitFilm Corner Pin with Motion Blur\",\n            \"value\": \"HitFilmCornerPin\",\n        },\n        {\n            \"label\": \"HitFilm Transform Data\",\n            \"value\": \"HitFilmTransformData\",\n        },\n        {\n            \"label\": \"Mistika Point Tracker File\",\n            \"value\": \"MistikaPointTracker\",\n        },\n        {\n            \"label\": \"MochaBlend Tracking Data\",\n            \"value\": \"MochaBlend\",\n        },\n        {\n            \"label\": \"Motion Basic Transform Data\",\n            \"value\": \"MotionBasicTransform\",\n        },\n        {\n            \"label\": \"Motion Corner Pin\",\n            \"value\": \"MotionCornerPin\",\n        },\n        {\n            \"label\": \"Nuke Ascii\",\n            \"value\": \"NukeAscii\",\n        },\n        {\n            \"label\": \"Nuke Corner Pin\",\n            \"value\": \"NukeCornerPin\",\n        },\n        {\n            \"label\": \"Nuke PowerMesh to Tracker Data\",\n            \"value\": \"NukePowerMesh\",\n        },\n        {\n            \"label\": \"Nuke Tracker Data - 7.0+\",\n            \"value\": \"Nuke7Tracker\",\n        },\n        {\n            \"label\": \"Quantel Corner Pin Data\",\n            \"value\": \"QuantelCornerPin\",\n        },\n        {\n            \"label\": \"SCRATCH Corner Pin Data\",\n            \"value\": \"AssimilateSCRATCHCornerPin\",\n        },\n        {\n            \"label\": \"Shake Tracking Data\",\n            \"value\": \"ShakeScript\",\n        },\n        {\n            \"label\": \"Silhouette Corner Pin\",\n            \"value\": \"SilhouetteCornerPin\",\n        },\n        {\n            \"label\": \"SynthEyes 2D Tracker Data\",\n            \"value\": \"SynthEyes2DTracker\",\n        },\n    ]\n</code></pre>"},{"location":"autoapi/server/settings/main.html","title":"main","text":"<p>Settings for the Mocha Pro Addon.</p>"},{"location":"autoapi/server/settings/main.html#server.settings.main.MochaProSettings","title":"<code>MochaProSettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Settings for the Mocha Pro Addon.</p> Source code in <code>server/settings/main.py</code> <pre><code>class MochaProSettings(BaseSettingsModel):\n    \"\"\"Settings for the Mocha Pro Addon.\"\"\"\n    create: MochaProCreatorPlugins = SettingsField(\n        default_factory=MochaProCreatorPlugins,\n        title=\"Creator Plugins\")\n</code></pre>"}]}